package Java_Extend.Java_Collections.Method.hashCode_equals;

public class hashCode_General {

    /*

                                Метод hashCode()

     Метод hashCode позволяет задать некоторое числовое значение,
     которое будет соответствовать данному объекту или его хэш-код.
     По данному числу, например, можно сравнивать объекты.


     Например:

     Person tom = new Person("Tom");
     System.out.println(tom.hashCode()); // 2036368507


     Но мы можем задать свой алгоритм определения хэш-кода объекта:

     Например:

     class Person {

     private String name;

     public Person(String name){
     this.name=name;
        }

    @Override
    public int hashCode(){
        return 10 * name.hashCode() + 20456;    // здесь мы задали свой алгоритм хеширования
        }
    }



     Метод hashCode() может использоваться для неточного, но очень быстрого сравнения

     Представьте, что вы сортируете в алфавитном порядке список из тысяч слов,
     и вам нужно постоянно попарно сравнивать слова. А слова длинные, и букв в них много.
     В общем, такое сравнение будет идти очень долго.

     Однако его можно ускорить. Допустим, слова начинаются на разные буквы: сразу же понятно, что они разные.
     Вот если они начинаются на одинаковые буквы, тогда гарантий нет:
     в дальнейшем слова могут оказаться и равными, и различными

     Метод hashCode() работает по похожему принципу.
     Если его вызвать у объекта, то он вернет некое число — аналог первой буквы в слове.
     Это число обладает такими свойствами:

     * У одинаковых объектов всегда одинаковые hash-code
     * У разных объектов могут быть одинаковые hash-code, а могут быть разные
     * Если у объектов разные hash-code, объекты точно разные

     Последнее свойство и используется для ускоренного сравнения объектов:

     Сначала у двух объектов вычисляются hash-code. Если эти hash-code разные,
     то объекты точно разные, и сравнивать их дальше не нужно.

     А вот если hash-code одинаковые, придется все же сравнивать объекты с помощью equals


                             Контракты в коде


    Все Java-программисты договорились, что если они пишут свою реализацию метода equals()
    вместо стандартной (из класса Object), они также должны написать свою реализацию метода hashCode(),
    чтобы озвученные выше правила сохранялись.

    Такая договоренность называется контрактом.

    Если вы добавляете в свой класс только реализацию одного метода equals() или только hashCode(),
    вы грубо нарушаете контракт (нарушаете договоренность). Так делать нельзя.

    Если другие программисты будут использовать ваш код, он может работать неправильно.
    Более того, вы тоже будете использовать код, который работает на основе вышеозвученных контрактов.

    Важно!
    Все коллекции в Java при поиске элемента внутри коллекции сначала сравнивают hash-code объектов,
    а только потом вызывают для сравнения метод equals.

    Поэтому если вы напишете свой класс, а в нем новую функцию equals, но не напишете метод hashCode()
    или реализуете его с ошибками, коллекции могут неправильно работать с вашими объектами.

    Например, вы добавили объект в список, затем ищете его с помощью метода contains(),
    а коллекция ваш объект не находит.



     */


}


