package Java_Extend.Java_Collections.Set;

public class Set_General {
    /*

    Интерфейс Java Set

    Интерфейс Java Set, java.util.Set, представляет коллекцию объектов, где каждый объект уникален.
    Другими словами, один и тот же объект не может встречаться более одного раза в наборе.
    Интерфейс является стандартным и подтипом интерфейса Collection, что означает, что Set наследуется от Collection.

    Вы можете добавить любой объект в набор. Если набор не типизирован с использованием Java Generics,
    то вы можете даже смешивать объекты разных типов (классов) в одном наборе.
    Однако в действительности смешивание объектов разных типов в одном наборе не часто выполняется.

    Первое различие состоит в том, что один и тот же элемент не может встречаться в наборе более одного раза.
    Это отличается от списка, где каждый элемент может встречаться более одного раза.
    Второе отличие состоит в том, что элементы в Set не имеют гарантированного внутреннего порядка.
    Элементы в списке имеют внутренний порядок, и элементы могут быть повторены в этом порядке.

    Будучи подтипом Collection, все методы в интерфейсе Collection также доступны в интерфейсе Set.

    Поскольку Set — это интерфейс, вам нужно создать конкретную реализацию, чтобы использовать его. Вы можете выбрать:

    java.util.EnumSet;
    java.util.HashSet;
    java.util.LinkedHashSet;
    java.util.TreeSet.

    Коллекция Set создана для хранения множества элементов. Поэтому ее так и называют Set (множество).
    У этой коллекции есть три особенности.

    Операции над множеством

    С множеством можно делать только три операции:
    добавлять элементы во множество,
    удалять элементы из множества и проверять,
    есть ли во множестве определенный элемент.
    Все.

    Отсутствие порядка

    У элементов этой коллекции нет номеров. Нельзя получить элемент по его индексу
    или записать значение в коллекцию по определенному индексу. Методов get() и set() у множества нет.

    Уникальность элементов

    Все элементы множества уникальны. В отличие от списка, в множестве один элемент может быть только раз.
    Объект или находится во множестве, или нет: третьего не дано.
    Нельзя во «множество цветов» трижды добавить «черный цвет». Он там либо есть, либо его нет.

    Поиск элементов

    Когда вы добавляете во множество новый элемент, удаляете элемент, или проверяете наличие элемента,
    внутри метода выполняется поиск элемента.
    Элементы коллекции и переданный элемент сравниваются сначала
    по hashCode(), а если hashCode() совпадают, по equals.

    Метод equals выполняет полное сравнение элементов, тогда как hashCode только лишь вычисляет хеш-функцию,
    которая может принимать одинаковые значения для разных элементов.
    Соотношение между этими двумя методами всегда такое:
    если для двух объектов hashCode возвращает одинаковое значение,
    то equals при этом может быть false, однако если equals возвращает true,
    то hashCode обязан возвращать одинаковые значения.
    При создании собственных классов, если их предполагается использовать в наборах или словарях,
    вы должны переопределить эти два метода, чтобы коллекции работали с ними корректно.


    Сравнение коллекций: List vs Set

    Давайте сравним коллекции двух типов: List и Set.
    В чем же их основные отличия и когда выгоднее использовать одну, а когда – вторую.

    Давайте попробуем сравнить Список и Множество на примере детских игрушек.

    Коллекция List (Список) похожа на набор игрушек в детской комнате, стоящих возле стены.
    Можно добавить игрушку в конец списка. Можно вставить и в середину,
    если очень нужно (но часть игрушек придется передвинуть).

    У каждой игрушки есть порядковый номер. Можно взять игрушку по ее номеру
    или заменить игрушку номер 7 на игрушку номер 13. Можно удалить из списка игрушку номер 4.
    Ну и наконец, можно узнать количество всех игрушек в списке.

    Коллекция Set (Множество) больше похожа на игрушки, сброшенные в кучу.
    В кучу можно добавить игрушку, можно удалить игрушку из кучи. Но фиксированного номера у таких игрушек нет.

    Или допустим, вы выбираете ребенку игрушку на день рождения.
    Тогда вы в первую очередь думаете, есть у него такая игрушка или нет.
    Тогда все игрушки, которые у него есть, образуют множество игрушек, которые вы решили не покупать.

    С этой точки зрения порядок игрушек в наборе «уже есть» не играет роли,
    как и наличие у именинника двух одинаковых игрушек.
    Вас интересуют не сами игрушки и их количество, а игрушки как набор неких уникальных объектов.

    Вот для таких случаев вам и понадобится множество Set и его самый популярный представитель — класс HashSet.


    !!!В Java HashSet в своей реализации использует HashMap - другими словами, внутри HashSet мы просто отсекаем
    часть, где хранятся значения, а пользуемся частью которая хранит ключи.
    Поэтому значения в HashSet это на самом деле ключи в HashMap.


    Методы Set:

    add(Object o)	            Добавление элемента в коллекцию, если он отсутствует.
                                Возвращает true, если элемент добавлен.
    addAll(Collection c)	    Добавление элементов коллекции, если они отсутствуют.
    clear()             	    Очистка коллекции.
    contains(Object o)	        Проверка присутствия элемента в наборе. Возвращает true, если элемент найден.
    containsAll(Collection c)	Проверка присутсвия коллекции в наборе. Возвращает true,
                                если все элементы содержатся в наборе.
    equals(Object o)	        Проверка на равенство.
    hashCode()	                Получение hashCode набора.
    isEmpty()	                Проверка наличия элементов. Возвращает true если в коллекции нет ни одного элемента.
    iterator()	                Функция получения итератора коллекции.
    remove(Object o)	        Удаление элемента из набора.
    removeAll(Collection c)	    Удаление из набора всех элементов переданной коллекции.
    retainAll(Collection c)	    Удаление элементов, не принадлежащих переданной коллекции.
    size()	                    Количество элементов коллекции
    toArray()	                Преобразование набора в массив элементов.
    toArray(T[] a)	            Преобразование набора в массив элементов.
                                В отличии от предыдущего метода, который возвращает массив объектов типа Object,
                                данный метод возвращает массив объектов типа, переданного в параметре.







     */


}
