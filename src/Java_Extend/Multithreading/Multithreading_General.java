package Java_Extend.Multithreading;

public class Multithreading_General {

    /*
                                     *** Multithreading (Многопоточность) *

    Рассмотрим такую ситуацию - вас пригласили и других коллег на работу
    Среди прочих хлопот нужно подать бумажные документы для трудоустройства уставшему сотруднику HR-отдела.
    Чтобы ускорить процесс, претендентов на должность можно разделить на две группы
    и распределить их между двумя HR-менеджерами.
    В результате мы получаем ускорение процесса за счёт параллельной (parallel) работы по оформлению.

    Если же кадровик в компании один, можно снова разбить всех на две группы,
    например, собеседовать поочерёдно девушек и юношей.
    Или по другому принципу: если девушек больше, будем чередовать на одного юношу двух девушек.
    Такой способ организации работы называется многопоточным.
    Наш утомлённый кадровик переключается на разные группы для оформления из них очередного сотрудника.
    Групп, может быть, одиннадцать, а кадровиков – четыре. В этом случае многопоточная (multithreading)
    обработка будет происходить параллельно несколькими HR-ами,
    которые могут брать очередного человека из любой группы для обработки его документов.

        * Процессы
    Процессом (process) в данном случае будет организация работы приёма документов.
    В организации можно выделить несколько процессов: бухгалтерский учёт, разработка ПО,
    встречи с клиентами, работа склада и т. д.
    На каждый процесс выделены ресурсы:  помещение, сотрудники для его исполнения.

    Процессы изолированы друг от друга: у кадровиков отсутствует доступ в бухгалтерскую базу,
    а менеджеры по работе с клиентами не бегают по складу. Если процесс должен получить доступ к чужим ресурсам,
    необходимо наладить межпроцессное взаимодействие: служебные записки, совместные совещания.

        * Потоки
    Работа в процессе организована в виде потоков (java thread).
    Для отдела кадров, поток – это организация работы по обслуживанию группы.
    Внутри процесса потоки могут выполняться параллельно
    – два кадровика принимают две или более группы будущих сотрудников.

    Взаимодействие кадровиков с группами – обработку потоков внутри процесса – называют синхронизацией потоков.
    Равномерный (девушка – юноша – девушка – юноша) и с разными приоритетами (две девушки чередуются с одним юношей).

    Потоки имеют доступ к ресурсам процесса, к которому они относятся:
    группам к кадровику даны образцы бланков заявлений, ручки для заполнения документов.
    Но если потоки взаимодействуют с общими для них вещами – то возможны казусы.
    Если кадровик попросит крикнуть имя последнего человека в очереди – то, в случае с двумя группами,
    он не уверен заранее, что услышит женское имя или мужское.
    Подобные конфликты доступа к данным, блокировки и способы их разрешения – очень важная тема.

    Состояния потока
    Каждый поток пребывает в одном из следующих состояний (state):
        - Создан (New) – очередь к кадровику готовится, люди организуются.
        - Запущен (Runnable) – наша очередь выстроилась к кадровику и обрабатывается.
        - Заблокирован (Blocked) – последний в очереди юноша пытается выкрикнуть имя,
            но услышав, что девушка в соседней группе начала делать это раньше него, замолчал.
        - Завершён (Terminated) — вся очередь оформилась у кадровика и в ней нет необходимости.
        - Ожидает(Waiting) – одна очередь ждёт сигнала от другой.
    Организация потоков и их взаимодействие – это основа эффективной работы процессов.

        * Процесс
    Process (процесс) – выполняющийся экземпляр программы, которому Операционная Система (ОС) выделила память,
    процессорное время/ядра и прочие ресурсы. Важно, что память выделяется отдельно,
    адресные пространства различных процессов недоступны друг другу. Если процессам необходимо обмениваться данными,
    они могут это сделать с помощью файлов, каналов и иных способов межпроцессного взаимодействия.

       * Поток
    Java Thread (поток). Иногда, чтобы не путать с другими классами Java – Stream и подобными,
    потоки Java часто переводят как нить. Они используют выделенные для процесса ресурсы
    и являются способом выполнения процесса. Главный поток выполняет метод main и завершается.
    При выполнении процесса могут порождаться дополнительные потоки (дочерние).
    Потоки одного процесса могут между собой обмениваться данными.
    Многопоточность Java требует учитывать синхронизацию данных, не забывайте об этом.

    В Java процесс завершается тогда, когда закончил работу последний его поток.
    Для фоновых задач поток можно запустить как демон (daemon),
    отличие которого от обычного в том, что они будут принудительно завершены
    при окончании работы всех не-daemon потоков процесса.

    Пример:                                                                                                     *//**

    class PeopleQueue extends Thread    {// Наша очередь из сотрудников, наследник класса Thread
    private String[] names;

    PeopleQueue(String... names) {// Конструктор, аргумент- массив имен сотрудников
        this.names = names;
    }

    @Override
    public void run() { // Этот метод будет вызван при старте потока
        for (int i = 0; i < names.length; i++) { // Вывод в цикле с паузой 0.5 сек очередного сотрудника
            System.out.println("Обработаны документы: " + names[i]);
            try {
                sleep(500); // Задержка в 0.5 сек
            } catch (Exception e) {}
        }
    }
    }

    public class HR    {// Класс для демонстрации работы потока
        public static void main(String[] args) {
            // Создаем две очереди
            PeopleQueue queue1 = new PeopleQueue("Иван","Сергей","Николай","Фердинанд","Василий");
            PeopleQueue queue2 = new PeopleQueue("Мария","Людмила","Алиса","Карина","Ольга");

            System.out.println("Начали!"); // Сообщение из главного потока программы
            queue1.start();    //Запускаем одну очередь (дочерний поток)
            queue2.start(); //Запускаем вторую (дочерний поток)
        }
    }                                                                                                                   *//*

        Запустим программу. В консоли виден вывод сообщения главным потоком.
        Далее, каждый дочерний поток queue1 и queue2 поочередно выводят сообщения в общую для них консоль
        об очередном обработанном сотруднике. Один из возможных вариантов работы программы:

        Начали!
    Обработаны документы: Мария
    Обработаны документы: Иван
    Обработаны документы: Людмила
    Обработаны документы: Сергей
    Обработаны документы: Алиса
    Обработаны документы: Николай
    Обработаны документы: Карина
    Обработаны документы: Фердинанд
    Обработаны документы: Ольга
    Обработаны документы: Василий

    Process finished with exit code 0















     */




}
