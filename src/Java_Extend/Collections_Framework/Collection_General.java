package Java_Extend.Collections_Framework;

public class Collection_General {

    /*


    Контейнерами или коллекциями называют классы, которые позволяют хранить и обрабатывать много объектов сразу.

    Тут есть некоторая неоднозначность с именами.
    Хотя в большинстве языков программирования все эти структуры данных принято называть коллекциями,
    в Java это не так. В языке Java некоторые из этих классов реализуют интерфейс Collection,
    в то время как другие — нет.


    Поэтому, чтобы не путаться, коллекциями называют только коллекции в узком смысле
    (классы должны реализовывать интерфейс Collection).
    Это все коллекции типа List, Set и Queue.
    Коллекции же в широком смысле принято называть контейнерами.
    К ним относятся классы типа Map и массивы.


    Практически все коллекции реализованы на основе массивов.
    Поскольку коллекции инкапсулируют массивы, массивы всегда работают быстрее, чем любая коллекция.
    Но в любой коллекции функций больше, чем массивов.

    Массивы имеют фиксированный размер, и один и тот же массив может хранить данные только одного и того же типа
    (базовый тип / ссылочный тип), тогда как коллекции JAVA могут хранить и управлять набором данных
    с нефиксированным номером. Все коллекции JAVA находятся в пакете java.util.
    Коллекция JAVA может хранить данные только ссылочных типов, но не базовые типы данных.


    Позвольте мне рассказать о причинах генерации наборов: в мире нет набора, только массивы (язык C).

    Некоторые люди хотят иметь массив, который можно расширять автоматически, поэтому есть список.

    Некоторые люди хотят иметь уникальный массив, поэтому есть набор.

    Некоторые люди хотят, чтобы количество групп автоматически отсортировывалось,
    поэтому есть TreeSet, TreeList, Tree **.


                             ***Разнице между коллекциями и массивами***

    1. Массив объявляет тип содержащихся в нем элементов, а коллекция - нет.
    Это потому, что коллекции хранят свои элементы в форме объекта.

    2. Экземпляр массива имеет фиксированный размер и не может быть масштабирован.
    Коллекция может динамически изменять свой размер по мере необходимости.

    3. Массив - это структура данных, доступная для чтения / записи,
    нет возможности создать массив только для чтения.
    Однако вы можете использовать метод ReadOnly,
    предоставленный коллекцией, чтобы использовать коллекцию только для чтения.
    Этот метод вернет версию коллекции только для чтения.


                                    Java Collection Framework

    Java Collection Framework — иерархия интерфейсов и их реализаций,
    которая является частью JDK и позволяет разработчику пользоваться большим количеством структур данных из «коробки».

    На вершине иерархии в Java Collection Framework располагаются 2 интерфейса: Collection и Map.
    Эти интерфейсы разделяют все коллекции, входящие во фреймворк на две части по типу хранения данных:
    простые последовательные наборы элементов и наборы пар «ключ — значение» (словари).



                            (i) Iterable                                                     (i) Map
                                 |                                                         |          \
                          (i) Collection                                                   |       Hashtable
               /                 |                    \                                    |           |
          (i) List          (i) Queue              (i) Set                                 |      LinkedHashMap
             |                |      |                 |      \                            |           |
             |                |  PriorityQueue         |     HashSet                       |        HashMap
             |                |                        |          |                        |
         ArrayList         (i) Deque                   |     LinkedHashSet            (i)SortedMap
             |                |                        |                                   |
         LinkedList---------->|                 (i) SortedSet                           TreeMap
             |                |                        |
           Vector         ArrayDeque                 TreeSet
             |
           Stack




                                        *Collection

    Коллекция - это самый простой интерфейс коллекции, в котором объявляются общие методы,
    применимые к коллекциям JAVA (включая только Set и List). И Set, и List наследуют Collection.

        boolean add (Object o): добавить ссылку на объект в коллекцию

        void clear (): удалить все объекты в коллекции, то есть больше не содержать ссылок на эти объекты

        boolean isEmpty (): определяет, пуст ли набор

        boolean contains (Objecto): определяет, содержит ли коллекция ссылку на конкретный объект.

        Iterartor iterator (): возвращает объект Iterator, который можно использовать для обхода элементов в коллекции.

        boolean remove (Objecto): удалить ссылку на объект из коллекции

        int size (): возвращает количество элементов в коллекции

        Object [] toArray (): возвращает массив, включающий все элементы в коллекции



    Примечание: для всех элементов коллекции используются методы Iterator () и toArray ().

    Первый возвращает объект Iterator, а второй возвращает массив, содержащий все элементы в коллекции.

    Интерфейс Iterator объявляет следующие методы:

        hasNext (): определяет, завершен ли обход элементов в коллекции, если нет, вернуть true

        next (): вернуть следующий элемент

        remove (): удалить из коллекции последний элемент, возвращенный методом next ().



                                            ***Set

    Сет - простейший вид коллекции. Объекты в коллекции не сортируются определенным образом,
    и нет повторяющихся объектов. Интерфейс Set в основном реализует два класса реализации:

    HashSet: класс HashSet обращается к объектам в коллекции в соответствии с хэш-алгоритмом,
    и скорость доступа относительно высокая.

    TreeSet: класс TreeSet реализует интерфейс SortedSet и может сортировать объекты в коллекции.


    Использование Set: он хранит ссылку на объект, и нет повторяющихся объектов.                                   *//**

        Set set = newHashSet();

        String s1=newString("hello");

        String s2 = s1;

        String s3 = newString("world");

        set.add(s1);

        set.add(s2);

        set.add(s3);

        System.out.println (set.size ()); // Количество объектов в наборе для печати - 2.                           *//*

    Как метод add () Set определяет, был ли объект сохранен в коллекции?                                           *//**

        boolean isExists = false;

        Iterator iterator = set.iterator();

        while(iterator.hasNext())  {

        String oldStr = it.next();

        if(newStr.equals(oldStr)){

                isExists=true;

                }
        }                                                                                                           *//*

    Set имеет точно такой же интерфейс, что и Collection, поэтому в нем нет дополнительных функций,
    в отличие от двух предыдущих списков. На самом деле Set - это Collection, но поведение другое
    (это типичное применение наследования и полиморфизма: показывает другое поведение).
    Set не сохраняет повторяющиеся элементы.

    Set: каждый элемент, хранящийся в Set, должен быть уникальным,
    потому что Set не хранит повторяющиеся элементы.
    Элементы, добавленные в Set, должны определять метод equals (),
    чтобы гарантировать уникальность объекта.
    У Set и Collection абсолютно одинаковый интерфейс. Интерфейс Set не гарантирует поддержание порядка элементов.

    HashSet: набор, предназначенный для быстрого поиска. Объект, хранящийся в HashSet, должен определять hashCode ().

    TreeSet: установите порядок сохранения, нижний слой представляет собой древовидную структуру.
    Используйте его для извлечения упорядоченных последовательностей из Set.

    LinkedHashSet: имеет скорость запроса HashSet и использует связанный список внутри
    для поддержания порядка элементов (порядка вставки).
    Поэтому при использовании итератора для обхода Set результаты будут отображаться в порядке вставки элементов.



                                                   ***List

    Особенностью List является то, что его элементы хранятся линейно,
    а повторяющиеся объекты могут храниться в коллекции.

    Основные классы реализации интерфейса List включают:

    ArrayList (): представляет массив, длину которого можно изменить.
    Доступ к элементам может быть произвольным, а скорость вставки и удаления элементов в ArrayList () низкая.

    LinkedList (): используйте структуру данных связанного списка в реализации.
    Скорость вставки и удаления высокая, но скорость доступа низкая.

    Для произвольного доступа к списку он предназначен только для случайного извлечения элементов,
    расположенных в определенном месте. Метод get (int index) List возвращает объект в позицию индекса,
    указанную индексом параметра в коллекции, а индекс начинается с «0».
    Два основных метода получения всех объектов в коллекции:

     Для цикла и метода get ():                                                                                    *//**

        for(int i=0; i<list.size(); i++){

            System.out.println(list.get(i));

        }                                                                                                           *//*

    Используйте Итератор:                                                                                          *//**

        Iterator it = list.iterator();

        while(it.hashNext()){

            System.out.println(it.next());

        }                                                                                                           *//*


    Два функциональных метода List: один - это базовый ArrayList,
    который имеет преимущество произвольного доступа к элементам;
    другой - более мощный LinkedList, который не предназначен для быстрого произвольного доступа,
    но имеет более общий метод.

    Список: Порядок - самая важная особенность List, он гарантирует поддержание определенного порядка элементов.
    List добавляет множество методов в Collection, что позволяет вставлять и удалять элементы из середины List.
    Список может генерировать ListIterator, который можно использовать для обхода списка в двух направлениях,
    а также для вставки и удаления элементов из середины списка.

    ArrayList: список реализуется массивом. Разрешен быстрый произвольный доступ к элементам,
    но скорость вставки и удаления элементов из середины списка очень медленная.
    ListIterator следует использовать только для обхода ArrayList сзади наперед,
    а не для вставки и удаления элементов, поскольку это намного дороже, чем LinkedList.

    LinkedList: оптимизирован для последовательного доступа,
    накладные расходы на вставку и удаление в середине списка невелики.
    Произвольный доступ относительно медленный. (Вместо этого используйте ArrayList.)
    Существуют также следующие методы:
    addFirst (), addLast (), getFirst (), getLast (), removeFirst () и removeLast (),
    эти методы (не определенные ни в каком интерфейсе или базовом классе)
    Делает LinkedList может использоваться как стек, очередь и двусторонняя очередь.


                                           ***Map

    Map - это набор сопоставленных ключевых объектов и объектов-значений,
    каждый элемент которого содержит пару ключевых объектов и объектов-значений.
    Карта не наследуется от интерфейса Коллекции. При извлечении элементов из коллекции Map,
    пока указан ключевой объект, будет возвращен соответствующий объект значения.


    Общие методы карты:

    1. Добавить и удалить операции:

    void put(K key, V value): добавить элементы в коллекцию

    void remove (Object key): удаление элементов, связанных с KEY

    void putAll (Mapt): добавить к изображению все элементы из определенного изображения.

    void clear (): удалить все сопоставления с изображения



    2. Операция запроса:

    Object get (Object key): получить значение, связанное с ключом.
    Ключевые объекты в коллекции Map не могут повторяться,
    то есть результат сравнения любых двух ключевых объектов с помощью метода equals () является ложным,
    но любое количество ключей может быть сопоставлено исключительно с одним и тем же объектом значения.

    3. Функция Map:

    Метод put (Object key, Object value) добавляет «значение» (хочу что-то получить) и «ключ»,
    связанный с «значением» (используйте его для поиска).
    Метод get (Object key) возвращает «значение», связанное с данным «ключом».

    Стандартная библиотека классов Java содержит несколько различных карт:
    HashMap, TreeMap, LinkedHashMap, WeakHashMap, IdentityHashMap.
    Все они имеют одну и ту же базовую карту интерфейса, но поведение, эффективность,
    стратегия сортировки, жизненный цикл сохраненного объекта и
    стратегия определения «ключевой» эквивалентности различаются.

    Повышение эффективности выполнения - большое преимущество Map.
    Глядя на то, что делает get (), вы поймете, почему поиск «ключей» в ArrayList довольно медленный.
    И именно здесь HashMap ускоряется. HashMap использует специальное значение, называемое «хеш-кодом»,
    чтобы заменить медленный поиск ключей.
    «Хэш-код» - это «относительно уникальное» значение типа int, используемое для представления объекта.
    Оно генерируется путем преобразования некоторой информации об объекте.
    Все объекты Java могут генерировать хэш-коды,
    потому что hashCode () - это метод, определенный в базовом классе Object.

    HashMap использует hashCode () объекта для быстрого запроса.
    Этот метод может значительно повысить производительность.

    Карта. Поддерживайте актуальность пар "ключ-значение", позволяя находить "значения" по "ключам".

    HashMap: карта основана на реализации хеш-таблиц. Стоимость вставки и запроса «пар ключ-значение» фиксирована.
    Емкость и коэффициент загрузки можно установить с помощью конструктора,
    чтобы настроить производительность контейнера.

    LinkedHashMap: похож на HashMap, но при итерации по нему порядок, в котором получены «пары ключ-значение»,
    является порядком вставки или порядком наименее использованного (LRU).
    Только немного медленнее, чем HashMap. Это быстрее в итеративном доступе,
    потому что он использует связанный список для поддержания внутреннего порядка.

    TreeMap: основан на реализации красно-черной древовидной структуры данных.
    При просмотре «ключей» или «пар ключ-значение» они будут отсортированы
    (порядок определяется Comparabel или Comparator).
    Особенностью TreeMap является сортировка полученных результатов.
    TreeMap - единственная карта с методом subMap (), который может возвращать поддерево.

    WeakHashMao: карта слабого ключа (weak key), объекты, используемые в карте, также могут быть освобождены:
    это разработано для решения особых проблем.
    сли никакая ссылка за пределами карты не указывает на определенный «ключ»,
    этот «ключ» может быть переработан сборщиком мусора.

    IdentifyHashMap: используйте == вместо equals () для сравнения хеш-карт для «ключей».
    Создан для решения особых задач.



                                            *Отличие

    Разница между Collection и Map
    Количество элементов, хранящихся в каждом контейнере, разное.
    Тип коллекции, каждая позиция имеет только один элемент.
    Тип карты, содержащий пару ключ-значение, например небольшая база данных
    (например, очень популярная сейчас MongoDB - это ключ-значение).


    Описание функции

    List, Set и Map обрабатывают все удерживаемые объекты как типы объектов.

    Collection, List, Set и Map являются интерфейсами и не могут быть созданы.

    Унаследованные от них ArrayList, Vector, HashTable и HashMap являются конкретными классами,
    и их можно создавать. Контейнер векторов точно знает, какой тип объекта он содержит.
    Vector не выполняет проверку границ.

    List: элементы будут храниться в определенном порядке, поэтому порядок,
    в котором они извлекаются, может отличаться от порядка, в котором они были размещены.

    Set: не может содержать повторяющиеся элементы.


                                                *Резюме

    1. Если это связано со стеком, очередью и другими операциями,
    вам следует рассмотреть возможность использования List.
    Для быстрой вставки и удаления элементов вы должны использовать LinkedList.
    Если вам нужно быстро и произвольно получить доступ к элементам, вы должны использовать ArrayList.

    2. Если программа находится в однопоточной среде или доступ осуществляется только в одном потоке,
    рассмотрите несинхронизированные классы, которые более эффективны.
    Если несколько потоков могут работать с классом одновременно, следует использовать синхронизированные классы.

    3. Помимо использования TreeSet и TreeMap, когда требуется сортировка,
    следует использовать HashSet и HashMap, поскольку они более эффективны.

    4. Обратите особое внимание на работу хеш-таблицы,
    и методы equals и hashCode должны быть правильно реализованы в ключевом объекте.

    5. Класс контейнера может содержать только ссылки на объекты (указатели на объекты)
    вместо копирования информации об объекте в определенную позицию в последовательности.
    Как только объект помещается в контейнер, информация о типе объекта теряется.

    6. Попытайтесь вернуть интерфейс вместо фактического типа,
    например, вернуть List вместо ArrayList,
    если вдруг вам нужно изменить ArrayList на LinkedList в будущем,
    код клиента не нужно было изменять. Это для абстрактного программирования.





     */


}
