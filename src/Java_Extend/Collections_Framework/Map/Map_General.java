package Java_Extend.Collections_Framework.Map;

public class Map_General {

    /*

    Map — это структура данных, которая содержит набор пар “ключ-значение”

    Официальное русское название — “ассоциативный массив”, но его используют нечасто
    Более распространены варианты “словарь”, “карта”, или (чаще всего) — сленговый англицизм “мапа”.

    Внутри Map данные хранятся в формате “ключ”-”значение”, то есть по парам.
    И в качестве ключей, и в качестве значений могут выступать любые объекты — числа,
    строки или объекты других классов.

    По своей структуре данных напоминает словарь, поэтому ее часто так и называют.
    В то же время, Map является интерфейсом, и в стандартном jdk содержит основные реализации:
    Hashmap, LinkedHashMap, Hashtable, TreeMap. Самая используемая реализация — Hashmap

     Каждый ключ связан с определенным значением. После сохранения на карте вы можете позже найти значение,
     используя только ключ.

     Интерфейс не является подтипом интерфейса Collection.
     Следовательно, он немного отличается от остальных типов коллекций.

     Поскольку Map является интерфейсом, вам необходимо создать конкретную реализацию интерфейса для его использования.
     API коллекций содержит следующие:

     java.util.HashMap;
     java.util.Hashtable;
     java.util.EnumMap;
     java.util.LinkedHashMap;
     java.util.IdentityHashMap;
     java.util.Properties;
     java.util.TreeMap;
     java.util.WeakHashMap.

     !!!Только объекты могут быть вставлены
     Только объекты могут быть использованы в качестве ключей и значений.
     Если вы передаете примитивные значения (например, int, double и т. Д.) в качестве ключа или значения,
     они будут автоматически упакованы перед передачей в качестве параметров.
     Вот пример параметров примитива auto-boxing, передаваемых методу put():

     mapA.put("key", 123);
     Значение, переданное методу put() в приведенном выше примере, является примитивом int.
     Java автоматически упаковывает его внутри экземпляра Integer,
     поскольку для put() в качестве ключа и значения требуется экземпляр Oject.
     Автобокс также может произойти, если вы передадите примитив в качестве ключа.

     Последующие вставки с тем же ключом
     Заданный ключ может появляться на карте только один раз.
     Это означает, что только одна пара ключ + значение для каждого из них может существовать одновременно.
     Другими словами, для ключа «key1» в одном экземпляре может храниться только одно значение.
     Конечно, вы можете хранить значения одного и того же ключа в разных экземплярах карты.

     Если вы вызываете put() более одного раза с одним и тем же ключом,
     последнее заменяет существующее значение для данного ключа

     Нулевые ключи не допускаются
     Обратите внимание, что ключ не может быть нулевым!

     Карта использует методы ключа hashCode() и equals() для внутреннего хранения пары ключ-значение,
     по-этому, если ключ имеет значение null, карта не может правильно разместить пару внутри.

     Допустимы нулевые значения
     Значение пары ключ + значение, хранящееся на карте, может быть нулевым, так что это совершенно правильно:

     mapA.put("D", null);
     Просто имейте в виду, что вы получите null, когда позже вызовете get() с этим ключом:

     Object value = mapA.get("D");
     Переменная value будет иметь значение null после выполнения этого кода,
     если нулевое значение было вставлено для этого ключа ранее (как в предыдущем примере).

     Вставка всех элементов с другой карты
     Интерфейс имеет метод putAll(), который может копировать все пары ключ-значение (записи)
     из другого экземпляра в себя. В теории множеств это также называется объединением двух экземпляров Map.

     Пример:

        Map mapA = new HashMap();
        mapA.put("key1", "value1");
        mapA.put("key2", "value2");
        Map mapB = new HashMap();
        mapB.putAll(mapA);


                                *Как получить элементы.

     Чтобы получить определенный элемент, вызываем метод get(),
     передавая ключ для этого элемента в качестве параметра:

     String element1 =(String) mapA.get("key1");
     Метод get() возвращает Java-объект, если не заданы Дженерики приводим к нужному типу.



                            *Возвращение значения по умолчанию

     Интерфейс имеет метод getOrDefault(), который может возвращать значение по умолчанию,
     предоставленное вами – в случае, если никакое значение не сохранено с помощью данного ключа:

        Map map = new HashMap();
        map.put("A", "1");
        map.put("B", "2");
        map.put("C", "3");
        Object value = map.getOrDefault("E", "default value");

     В этом примере создается карта и в ней хранятся три значения с использованием ключей A, B и C.
     Затем вызывается метод Map getOrDefault(), передавая в качестве ключа строку String E
     вместе со значением по умолчанию – значением String по умолчанию.
     Поскольку карта не содержит объектов, хранящихся в ключе E, будет возвращено заданное значение по умолчанию.


                                *Проверка содержится ли ключ

     Используется метод containsKey():

        boolean hasKey = mapA.containsKey("123");

     После выполнения этого кода переменная hasKey будет иметь значение true,
     если пара ключ + значение была вставлена ранее с помощью строкового ключа 123,
     и false, если такая пара ключ + значение не была вставлена.


                             *Проверка содержится ли значение

     Используется метод containsValue():

     boolean hasValue = mapA.containsValue("value 1");
     После выполнения этого кода переменная hasValue будет содержать значение true,
     если пара ключ-значение была вставлена раньше, со строковым значением «значение 1», и false, если нет.



     У интерфейса Map существует 3 метода, которые возвращают перечень элементов:
        - keySet() — возвращает множество(Set) ключей;
        - values() — возвращает коллекцию(Collection) значений;
        - entrySet() — возвращает множество(Set) наборов “ключ-значение”.


                                        *Перебор ключей

     Существует несколько способов итерации ключей, хранящихся на карте. Наиболее часто используемые методы:

       - С помощью ключа Iterator.
       - Через цикл for-each.
       - Через поток.

     --Использование ключевого итератора
     С помощью метода keySet():

        Iterator iterator = mapA.keySet().iterator();
        while(iterator.hasNext(){
        Object key   = iterator.next();
        Object value = mapA.get(key);
        }

     Как вы можете видеть, ключ Iterator возвращает каждый ключ, сохраненный в Map,
     один за другим (по одному для каждого вызова next()).
     Получив ключ, вы можете получить элемент, сохраненный для этого ключа, с помощью метода get().


     --Использование цикл for-each
     В Java 5 вы также можете использовать цикл for-each для итерации ключей, хранящихся на карте:

        for(Object key : mapA.keySet()) {
        Object value = mapA.get(key);
        }
     Эффект приведенного выше кода очень похож на код, показанный в предыдущем разделе.

     --Использование ключевого потока
     Интерфейс Stream является частью Java Stream API, который был добавлен в Java 8.
     Сначала вы получаете ключ Set из карты, и из него вы можете получить Stream:

        Map map = new HashMap<>();
        map.put("one", "first");
        map.put("two", "second");
        map.put("three", "third");
        Stream stream = map.keySet().stream();
        stream.forEach((value) -> {
        System.out.println(value);
        });

                                    *Итерация значений

     Также возможно просто перебрать значения, хранящиеся в Map, с помощью метода values(). Варианты:

     - Использование итератора.
     - Использование цикла.
     - Использование потока значений.

     --Использование Value Iterator
     Первый способ – это получить экземпляр итератора значения из значения Set и выполнить итерацию:

        Iterator iterator = map.values().iterator();
        while(iterator.hasNext()) {
            Object nextValue  iterator.next();
        }
     Поскольку набор неупорядочен, у вас нет никаких гарантий относительно порядка, в котором значения повторяются.


     --Использование for-each
     Второй метод – это цикл Java for-each:

        for(Object value : mapA.values()){
            System.out.println(value);
        }
    В этом примере будут распечатаны все значения, хранящиеся в переменной mapA MapA.

     --Использование потока
     Подразумевает использование потока значений с помощью API-интерфейса Stream.
     Сначала вы получаете значение Set из карты, а из значения Set вы можете получить поток:

        Map map = new HashMap<>();
        map.put("one", "first");
        map.put("two", "second");
        map.put("three", "third");
        Stream stream = map.values().stream();
        stream.forEach((value) -> {
        System.out.println(value);
        });


                                    *Итерация записей

     Под записями подразумеваются пары ключ + значение. Существует два способа:

     - Использование итератора ввода.
     - Использование цикла for-each.


     --Использование итератора ввода
     Пример:

        Set entries = map.entrySet();
        Iterator iterator = entries.iterator();
        while(iterator.hasNext()) {
            Map.Entry entry =(Map.Entry) iterator.next();
            Object key = entry.getKey();
            Object value = entry.getValue();
        }
     Обратите внимание, как ключ и значение могут быть получены из каждого экземпляра Map.Entry.
     Имейте в виду, что приведенный выше код можно сделать немного лучше, используя Map,
     типизированную с помощью Generics, как показано далее в этом руководстве.


     Использование For-Each
     Пример:

        for(Object entryObj : map.entrySet()){
          Map.Entry entry =(Map.Entry) entryObj;
          Object key = entry.getKey();
          Object value = entry.getValue();
        }
     Обратите внимание, что этот пример тоже можно сделать немного красивее, используя универсальную карту.



                                        *Удаление записей

     Вы удаляете записи, вызывая метод remove(Object key).
     Таким образом, вы удаляете пару (ключ, значение), соответствующую ключу:

        mapA.remove("key1");
     После выполнения этой инструкции карта, на которую ссылается mapA,
     больше не будет содержать запись (пара ключ + значение) для ключа key1.


                                       *Удаление всех записей
     Используется метод clear():

        mapA.clear();

                                        *Замена записи
     Можно заменить элемент, используя метод replace().
     Он будет вставлять новое значение только в том случае, если к ключу сопоставимо существующее значение.
     В ином случае никакое значение не вставлено. Это отличается от того, как работает метод put(),
     который всегда вставляет значение, несмотря ни на что.

     Пример:

        Map map = new HashMap();
        map.replace("key", "new value");   //nothing is replaced, no mapping to "key"
        map.put("key", "value");           //now the map contains an entry on "key"
        map.replace("key", "newer value"); //now the entry is replaced

     После выполнения этого кода экземпляр Map будет содержать более новое значение String для ключа String.


                                    *Количество записей

     Вы можете узнать количество записей, используя метод size().
     Количество записей в Java-карте также называется размером карты – отсюда и имя метода size(). Вот пример:

        int entryCount = mapA.size();


                                   *Проверка, пуста ли карта

     Интерфейс имеет специальный метод для проверки isEmpty() и возвращает:

     true, если экземпляр Map содержит 1 или более записей;
     если карта содержит 0 записей, isEmpty() вернет false.


                                        *Общие карты

     По умолчанию вы можете поместить любой объект в карту,
     но Generics из Java 5 позволяет ограничить типы объектов,
     которые вы можете использовать как для ключей, так и для значений в карте:

        Map map = new HashMap();
     Эта карта теперь может принимать только объекты String для ключей и экземпляры MyObject для значений.
     Затем вы можете получить доступ к итерированным ключам и значениям без их приведения. Вот как это выглядит:

        for(MyObject anObject : map.values()){
        //do someting with anObject...
        }
        for(String key : map.keySet()){
        MyObject value = map.get(key);
        //do something to value
        }



                                       *Функциональные операции

    Интерфейс имеет несколько функциональных операций, добавленных из Java 8.
    Они позволяют взаимодействовать с Map в более функциональном стиле. Например,
    вы передаете лямбда-выражение в качестве параметра этим методам.
    Функциональные методы работы:

        compute();
        computeIfAbsent();
        computeIfPresent();
        merge().
        compute()

    Метод принимает ключевой объект и лямбда-выражение в качестве параметров.
    Лямбда-выражение должно реализовывать интерфейс java.util.function.BiFunction. Вот пример:

    map.compute("123",(key, value) -> value == null ? null : value.toString().toUpperCase());
    Метод compute() будет вызывать лямбда-выражение внутри себя, передавая ключевой объект и любое значение,
    сохраненное в Map для этого ключевого объекта, в качестве параметров лямбда-выражения.
    Какое бы значение не возвращалось лямбда-выражением, оно сохраняется вместо текущего значения этого ключа.
    Если лямбда-выражение возвращает ноль, запись удаляется. Там не будет ключа -> нулевое отображение хранится на карте.
    Если лямбда-выражение выдает исключение, запись также удаляется.
    В приведенном выше примере вы можете видеть, что лямбда-выражение проверяет, является ли значение,
    сопоставленное данному ключу, нулевым или нет, перед вызовом toString(). ToUpperCase() для него.


        computeIfAbsent()
    Метод Map computeIfAbsent() работает аналогично методу compute():

    Лямбда-выражение вызывается, только если для данного ключа уже не существует записи.
    Значение, возвращаемое лямбда-выражением, вставляется в карту. Если возвращается ноль, запись не вставляется.
    Если лямбда-выражение генерирует исключение, запись также не вставляется.
    Вот пример:


        map.computeIfAbsent("123",(key) -> "abc");
    Этот пример на самом деле просто возвращает постоянное значение – строку 123.
    Однако лямбда-выражение могло вычислить значение любым необходимым способом – например,
    извлечь значение из другого объекта или объединить его с другими значениями и т. д.


        computeIfPresent()
    Метод работает противоположно computeIfAbsent(). Он вызывает только лямбда-выражение,
    переданное ему в качестве параметра, если в Map уже существует запись для этого ключа:


        map.computeIfPresent("123",(key, value) -> value == null ? null : value.toString().toUpperCase());
    Значение, возвращаемое лямбда-выражением, будет вставлено в экземпляр Map.
    Если лямбда-выражение возвращает ноль, запись для данного ключа удаляется.
    Если лямбда-выражение выдает исключение, оно перебрасывается,
    и текущая запись для данного ключа остается неизменной.


        merge()
    Метод принимает в качестве параметров ключ, значение и лямбда-выражение, реализующее интерфейс BiFunction.

    Если в карте нет записи для ключа или если значение для ключа равно нулю, значение,
    переданное в качестве параметра методу merge(), вставляется для данного ключа.
    Однако, если существующее значение уже сопоставлено с данным ключом, вместо этого вызывается лямбда-выражение,
    переданное как параметр. Таким образом, лямбда-выражение получает возможность объединить существующее значение
    с новым значением. Значение, возвращаемое им, затем вставляется в карту для данного ключа.
    Если лямбда-выражение возвращает ноль, запись для данного ключа удаляется.
    Если в лямбда-выражении выдается исключение, оно перебрасывается,
    и текущее отображение для данного ключа сохраняется без изменений.
    Вот пример:

        map.merge("123", "XYZ",(oldValue, newValue) -> newValue + "-abc");
    В этом примере будет вставлено значение XYZ в карту, если значение не сопоставлено с ключом (123)
    или если значение NULL сопоставлено с ключом. Если ненулевое значение уже сопоставлено с ключом,
    вызывается лямбда-выражение.
    Лямбда-выражение возвращает новое значение (XYZ) + значение -abc, что означает XYZ-abc.

        Метод Map:
        void clear()	Очистка хеш-таблицы
        boolean containsKey(Object key)	                Функция проверки присутствия объекта по ключу
        boolean containsValue(Object value)	            Функция проверки присутствия объекта по значению
        Set<Map.Entry<K,V>> entrySet()	                Функция получения объекта в виде коллекции Set
        boolean equals(Object object)           	    Функция сравнения с объектом object
        Object get(Object key)	                        Функция получения записи по ключу
        boolean isEmpty()	                            Функция проверки наличия записей
        Set<K> keySet()	                                Функция получения записей в виде коллекции Set
        void put(K key, V value)	                    Функция добавления записи
        void putAll(Map<? extends K,? extends V> t) 	Функция добавления записей
        void remove(Object key)                 	    Метод удаления объекта по ключу key
        boolean remove(Object key, Object value)        Функция удаления записи по соответствию значений ключа и значения
        void replace(K key, V value)	                Замена значения value для записи с ключом key
        boolean replace(K key, V oldValue, V newValue)	Замена значения oldValue на newValue для записи с ключом key
        int size()	                                    Функция определения количества записей в хеш-таблице
        Collection<V> values()	                        Получение значений записей в виде коллекции




















     */


}
