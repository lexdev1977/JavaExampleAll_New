package Java_Extend.Multithreading;

public class Produce_Consume_General {

/*

                            Паттерн Produce Consumer (пример использования wait notify)

    Шаблон producer/consumer (производитель/потребитель)
    – простая и базовая реализация обмена данными между несколькими потоками.
    Поток-производитель отправляет объекты на условную обработку,
    потоки-потребители асинхронно принимают и обрабатывают их.

    Общий вид решения выглядит так. Продюсер отправляет объекты в специальную коллекцию – буфер.
    Когда потребитель освобождается, он отправляет запрос на извлечение одного объекта из буфера.
    Если буфер пуст, потребитель блокируется и ждет, если буфер переполнен – ждет производитель.

    На практике реализовать этот паттерн можно множеством способов.
    Самый правильный способ для применения в бою – использовать готовую реализацию из стандартной библиотеки,
    объект типа BlockingQueue.

    Модификатор synchronized делает так, чтобы в каждый момент времени мог выполняться только один из методов,
    и только одним потоком. Этого достаточно для корректной работы пока буфер не пуст и не полон.
    При пустом или полном буфере управление явно перебрасывается на производителя или потребителя соответственно,
    с помощью методов notify() и wait().

    Пример реализации паттерна:
     !!!Замечание, в цикле на проверку условий работы потока, должен находится wait(), так как может случиться ситуация,
     что после выхода из цикла после него стоит wait() поток войдет в заморозку,
     и второй поток достигнув условия тоже уйдет в заморозку и разморозить друг друга они уже не смогут            *//**


     class ProduserConsumer<T>{
     private static final int BUFFER_MAX_SIZE = 40;
     private List<T> buffer = new LinkedList<>();

     synchronized void produce(T value) throws InterruptedException {
     while (buffer.size() == BUFFER_MAX_SIZE){
     wait();
     }
     buffer.add(value);
     notify();
     }

     synchronized T consumer() throws InterruptedException {
     while (buffer.size() == 0){
     wait();
     }
     T result = buffer.remove(0);
     notify();
     return result;

     }


     }


     */



}
