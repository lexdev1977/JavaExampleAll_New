package Java_Extend.Multithreading;

public class Mutex_Monitor_General {

    /*

                                             *** Мьютекс

    Мьютекс — это специальный объект для синхронизации потоков.
    Он «прикреплен» к каждому объекту в Java — это ты уже знаешь :)

    Неважно, пользуешься ли ты стандартными классами или создал собственные классы,
    скажем, Cat и Dog: у всех объектов всех классов есть мьютекс.

    Название «мьютекс» происходит от английского «MUTual EXclusion» — «взаимное исключение»,
    и это отлично отражает его предназначение.

    Задача мьютекса — обеспечить такой механизм, чтобы доступ к объекту в определенное время был только у одного потока.

    Популярной аналогией мьютекса в реальной жизни можно считать «пример с туалетом».

    Когда человек заходит в туалет, он закрывает изнутри дверь на замок.

    Туалет выполняет роль объекта, доступ к которому получают несколько потоков.
    Замок на двери туалета — роль мьютекса, а очередь из людей снаружи — роль потоков.

    Замок на двери — мьютекс туалета: он гарантирует, что внутри одновременно может находиться только один человек.


    У мьютекса есть несколько важных особенностей.

    Во-первых, возможны только два состояния — «свободен» и «занят».

    Это упрощает понимание принципа работы: можно провести параллели
    с булевыми переменными true/false или двоичной системой счисления 1/0.

    Во-вторых, состояниями нельзя управлять напрямую.
    В Java нет механизмов, которые позволили бы явно взять объект,
    получить его мьютекс и присвоить ему нужный статус. Иными словами, ты не можешь сделать что-то типа:

           Object myObject = new Object();
           Mutex mutex = myObject.getMutex();
           mutex.free();

    Таким образом освободить мьютекс объекта нельзя. Прямой доступ к нему есть только у Java-машины.
    Программисты же работают с мьютексами с помощью средств языка.



                                            *** Монитор

    Монитор — это дополнительная «надстройка» над мьютексом.

    Фактически монитор — это «невидимый» для программиста кусок кода.

    Простой пример:                                                                                               *//**

            public class Main {

            private Object obj = new Object();

                public void doSomething() {

            //...какая-то логика, доступная для всех потоков

                    synchronized (obj) {

            //логика, которая одновременно доступна только для одного потока

                    }
                }
            }

                                                                                                                    *//*

    В блоке кода, который помечен словом synchronized, происходит захват мьютекса нашего объекта obj.

    Хорошо, захват-то происходит, но как именно обеспечивается «защитный механизм»?
    Почему при виде слова synchronized остальные потоки не могут пройти внутрь блока?

    Защитный механизм создает именно монитор!
    Компилятор преобразует слово synchronized в несколько специальных кусков кода.

    Еще раз вернемся к нашему примеру с методом doSomething() и дополним его:

    public class Main {                                                                                            *//**

   private Object obj = new Object();

   public void doSomething() {

       //...какая-то логика, доступная для всех потоков

       //логика, которая одновременно доступна только для одного потока
       synchronized (obj) {

           //выполнить важную работу, при которой доступ к объекту
           должен быть только у одного потока//
         obj.someImportantMethod();
    }
            }
                     }                                                                                              *//*




    Вот что будет происходить «под капотом» нашей программы после того, как компилятор преобразует этот код:


    public class Main {

   private Object obj = new Object();

   public void doSomething() throws InterruptedException {

       //...какая-то логика, доступная для всех потоков

       //логика, которая одновременно доступна только для одного потока:

       //до тех пор, пока мьютекс объекта занят -
       любой другой поток (кроме того, который его захватил), спит
       while (obj.getMutex().isBusy()) {
        Thread.sleep(1);
    }

    //пометить мьютекс объекта как занятый
       obj.getMutex().isBusy() = true;

       //выполнить важную работу, при которой доступ к объекту
       должен быть только у одного потока
       obj.someImportantMethod();

    //освободить мьютекс объекта
       obj.getMutex().isBusy() = false;
}
}


    Пример, конечно, ненастоящий. Здесь мы с помощью Java-подобного кода попытались отразить то,
    что происходит в этот момент внутри Java-машины. Однако этот псевдокод дает отличное понимание того,
    что на самом деле происходит с объектом и потоками внутри блока synchronized
    и как компилятор преобразует это слово в несколько «невидимых» для программиста команд.

    По сути, монитор в Java выражен с помощью слова synchronized.
    Весь код, который появился вместо слова synchronized в последнем примере, — это и есть монитор.





     */





}
