package Java_Extend.Other;

public class RegEx_General {
    /*

    Регулярное выражение (RegEx) – это шаблон для поиска строки в тексте.
    В Java исходным представлением этого шаблона всегда является строка, то есть объект класса String.
    Однако не любая строка может быть скомпилирована в регулярное выражение, а только та,
    которая соответствует правилам написания регулярного выражения – синтаксису, определенному в спецификации языка.

    Для написания регулярного выражения используются буквенные и цифровые символы,
    а также метасимволы – символы, имеющие специальное значение в синтаксисе регулярных выражений.

    String regex = ”java”; // шаблон строки ”java”;
    String regex = ”\\d{3}”; // шаблон строки из трех цифровых символов;

    Синтаксис регулярных выражений:

    Синтаксис регулярных выражений основан на использовании символов <([{\^-=$!|]})?*+.>,
    которые можно комбинировать с буквенными символами. В зависимости от роли их можно разделить на несколько групп:

                        1. Метасимволы для поиска совпадений границ строк или текста

    ^	начало строки
    $	конец строки
    \b	граница слова
    \B	не граница слова
    \A	начало ввода
    \G	конец предыдущего совпадения
    \Z	конец ввода
    \z	конец ввода


                        2. Метасимволы для поиска символьных классов

    \d	цифровой символ
    \D	нецифровой символ
    \s	символ пробела
    \S	непробельный символ
    \w	буквенно-цифровой символ или знак подчёркивания
    \W	любой символ, кроме буквенного, цифрового или знака подчёркивания
    .	любой символ


                        3. Метасимволы для поиска символов редактирования текста

    \t	символ табуляции
    \n	символ новой строки
    \r	символ возврата каретки
    \f	переход на новую страницу
    \ u 0085	символ следующей строки        \\ убрать пробел между чертой и u
    \ u 2028	символ разделения строк
    \ u 2029	символ разделения абзацев


                        4. Метасимволы для группировки символов

    [абв]	        любой из перечисленных (а,б, или в)
    [^абв]	        любой, кроме перечисленных (не а,б, в)
    [a-zA-Z]	    слияние диапазонов (латинские символы от a до z без учета регистра )
    [a-d[m-p]]	    объединение символов (от a до d и от m до p)
    [a-z&&[def]]	пересечение символов (символы d,e,f)
    [a-z&&[^bc]]	вычитание символов (символы a, d-z)


                        5. Метасимволы для обозначения количества символов – квантификаторы.
                        Квантификатор всегда следует после символа или группы символов.

    ?	один или отсутствует
    *	ноль или более раз
    +	один или более раз
    {n}	n раз
    {n,}	n раз и более
    {n,m}	не менее n раз и не более m раз


                        Жадный режим квантификатора

    Особенностью квантификаторов является возможность использования их в разных режимах:
    жадном, сверхжадном и ленивом. Сверхжадный режим включается добавлением символа «+» после квантификатора,
    а ленивый – символа «?». Например:

    "А.+а" // жадный режим
    "А.++а" // сверхжадный режим
    "А.+?а" // ленивый режим

    По умолчанию квантификатор работает в жадном режиме.
    Это означает, что он ищет максимально длинное совпадение в строке. В результате выполнения этого кода:
                                                                                                                   *//**
    public static void main(String[] args) {
        String text = "Егор Алла Александр";
        Pattern pattern = Pattern.compile("А.+а");
        Matcher matcher = pattern.matcher(text);
        while (matcher.find()) {
            System.out.println(text.substring(matcher.start(), matcher.end()));
        }
    }                                                                                                               *//*

    мы получим такой вывод:
                                                                                                                   *//**
    Алла Алекса
                                                                                                                    *//*
    Алгоритм поиска по заданному шаблону "А.+а", выполняется в следующей последовательности:

    - Перебираются все символы сначала, пока не найдется А
    - Далее идет точка - любой символ
    - .+ - говорит, что нужно проверять до конца строки на любой символ
     (По сути, Matcher, захватывает все строку до конца – в этом как раз и проявляется его «жадность».)
    - дойдя до конца, проверяем в обратном направлении начиная с конца на соответствие с символом - «а».
    - Matcher «помнит» количество повторений в шаблоне «.+» при котором он дошел до конца текста,
      поэтому он уменьшает количество повторений на единицу и проверяет соответствие шаблона тексту,
      до тех пор пока не будет найдено совпадение:

                        Сверхжадный режим квантификатора

    "А.++а" // сверхжадный режим

     - В сверхжадном режиме работа матчера аналогична механизму жадного режима.
        Отличие состоит в том, что при захватывании текста до конца строки поиск в обратном направлении не происходит.
     - После захвата всей строки матчер добавляет остаток шаблона и сравнивает с захваченной строкой.
        В нашем примере при выполнении метода main с шаблоном "А.++а" совпадений не будет найдено.
                                                                                                                   *//**
    Егор [ [А] лла Александр] a - совпадений нет
                                                                                                                    *//*

                        Ленивый режим квантификатора

    "А.+?а" // ленивый режим

    - В этом режиме на начальном этапе, как и в жадном режиме, ищется совпадение с первым символом шаблона:
    - Далее ищется совпадение со следующим символом шаблона – любым символом
    - В отличие от жадного режима, в ленивом ищется самое короткое совпадение в тексте,
      поэтому после нахождения совпадения со вторым символом шаблона, который задан точкой - любой символ
    - Matcher будет проверять соответствие текста остатку шаблона – символу «а»
    - Поскольку совпадение с шаблоном в тексте не найдено, Matcher добавляет еще один «любой символ» в шаблоне,
      так как он задан как один и более раз
    - В нашем случае через пару символов будет найдено совпадение, но конец текста ещё не достигнут.
    - Поэтому со следующей позиции проверка начинается с поиска первого символа шаблона - «А»
      по аналогичному алгоритму и далее повторяется вплоть до окончания текста.

    В результате работы метода main при использовании шаблона "А.+?а" мы получим следующий результат:
                                                                                                                   *//**
    Алла
    Алекса
                                                                                                                    *//*


                            Экранирование символов в регулярных выражениях

    Символ обратной косой черты «\» в строковых литералах в исходном коде Java интерпретируется
    как символ управляющей последовательности, который предупреждает компилятор,
    что следующий за ним символ — специальный и что его нужно особым образом интерпретировать. Например:
                                                                                                                   *//**
    String s=“The root directory is \nWindows”;//перенос Windows на новую строку
    String s=“The root directory is \u00A7Windows”;//вставка символа параграфа перед Windows
                                                                                                                    *//*

    Поэтому в строковых литералах, которые описывают регулярное выражение,
    и используют символ «\» (например, для метасимволов) его нужно удваивать,
    чтобы компилятор байт-кода Java не интерпретировал его по-своему. Например:

                                                                                                                   *//**
    String regex=”\\s”; // шаблон для поиска символов пробела
    String regex=”\\”Windows\\””; // шаблон для поиска строки ”Windows”
                                                                                                                    *//*

    Двойной символ обратной косой черты также следует использовать для экранирования символов
    задействованных в качестве специальных, если мы планируем их использовать как «обычные» символы. Например:
                                                                                                                   *//**
    String regex=”How\\?”; // шаблон для поиска строки “How?”
                                                                                                                    *//*











     */
}
