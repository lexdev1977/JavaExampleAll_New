package Java_Extend.Other;

public class Annotations_General {
/*
    Аннотация — это специальная конструкция языка, связанная с классом, методом или переменной,
    предоставляющая программе дополнительную информацию, на основе которой программа может предпринять дальнейшие
    действия или реализовать дополнительную функциональность, такую как генерация кода, проверка ошибок и т. д.

    Помимо использования стандартных аннотаций из пакета java.lang,
    можно также создавать свои аннотации и обрабатывать их.

    Аннотации начинаются с символа @. Например,
    в пакете java.lang определены аннотации @Override, @Deprecated и @SuppressWarnings.

    Сама по себе аннотация не выполняет никаких действий.
    Она просто предоставляет информацию, которую можно использовать во время компиляции или в рантайме.

    - Аннотация @Override используется для обозначения переопределенного метода из базового класса.

    - Аннотация @Deprecated используется для пометки устаревших методов или типов.

    - Аннотация @SuppressWarnings используется для подавления предупреждений компилятора.


    Аннотации в Java являются своего рода метками в коде, описывающими метаданные для функции/класса/пакета.
    Например, всем известная Аннотация @Override, обозначающая,
    что мы собираемся переопределить метод родительского класса.
    Да, с одной стороны, можно и без неё, но если у родителей не окажется этого метода
    существует вероятность, что мы зря писали код, т.к. конкретно этот метод может и не вызваться никогда,
    а с Аннотацией @Override компилятор нам скажет, что: "Я не нашел такого метода в родителях... что-то здесь нечисто".

    Каждая аннотаций имеет 2 главных, обязательных параметра:

    - Тип хранения (Retention);
    - Тип объекта над которым она указывается (Target).

                                            Тип хранения
    Под "типом хранения" понимается стадия до которой "доживает" наша аннотация внутри класса.
    Каждая аннотация имеет только один из возможных "типов хранения" указанный в классе RetentionPolicy:

    - SOURCE - аннотация используется только при написании кода и игнорируется компилятором
    (т.е. не сохраняется после компиляции). Обычно используется для каких-либо препроцессоров (условно),
    либо указаний компилятору
    - CLASS - аннотация сохраняется после компиляции, однако игнорируется JVM
    (т.е. не может быть использована во время выполнения). Обычно используется для каких-либо сторонних сервисов,
    подгружающих ваш код в качестве plug-in приложения
    - RUNTIME - аннотация, которая сохраняется после компиляции и подгружается JVM
    (т.е. может использоваться во время выполнения самой программы).
    Используется в качестве меток в коде, которые напрямую влияют на ход выполнения программы


                                    Тип объекта над которым указывается
    Данное описание стоит понимать практически буквально, т.к. в Java аннотации могут указываться над чем угодно
    (Поля, класса, функции, т.д.) и для каждой аннотации указывается, над чем конкретно она может быть задана.
    Здесь уже нет правила "что-то одно", аннотацию можно указывать над всем ниже перечисленным,
    либо же выбрать только нужные элементы класса ElementType:

    ANNOTATION_TYPE - другая аннотация
    CONSTRUCTOR - конструктор класса
    FIELD - поле класса
    LOCAL_VARIABLE - локальная переменная
    METHOD - метод класса
    PACKAGE - описание пакета package
    PARAMETER - параметр метода public void hello(@Annontation String param){}
    TYPE - указывается над классом

    Всего на момент версии Java SE 1.8 стандартная библиотека языка предоставляет нам 10 аннотаций.



                                                @Override
    Retention: SOURCE;
    Target: METHOD.

    Данная аннотация показывает, что метод над котором она прописана, наследован у родительского класса.

    Первая аннотация с которой сталкивался каждый начинающий Java-программист,
    при использовании IDE, которая настойчиво пихает эти @Override.
    Аннотация не только позволяет понять, какие методы были определены в этом классе впервые,
    а какие уже есть у родителей, что бесспорно повышает читаемость вашего кода,
    но также данная аннотация служит "самопроверкой", что вы не ошиблись при определении перегружаемой функции.


                                                @Deprecated
    Retention: Runtime;
    Target: CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE.

    Данная аннотация указывает на методы, классы или переменные, которые является "устаревшими"
    и могут быть убраны в последующих версиях продукта.

    С данной аннотацией обычно сталкиваются те, кто читает документацию каких-либо API,
    либо той же стандартной библиотеки Java. Иногда эту аннотацию игнорируют, т.к. она не вызывает никаких ошибок
    и в принципе сама по себе сильно жить не мешает. Однако главный посыл, который несет в себе данная аннотация
    – "мы придумали более удобный метод реализации данного функционала, используй его, не используй старый"
    -  ну, либо же - "мы переименовали функцию, а это так, для легаси оставили..."
    Если видите @Deprecated - лучше стараться не использовать то, над чем она висит,
    если в этом нет прям крайней необходимости и, возможно, стоит перечитать документацию,
    чтобы понять каким образом теперь реализуется задача, выполняемая устаревшим элементом.
    Например, вместо использований
    new Date().getYear() рекомендуется использовать Calendar.getInstance().get(Calendar.YEAR).



                                             @SuppressWarnings
    Retention: SOURCE;
    Target: TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE

    Данная аннотация отключает вывод предупреждений компилятора, которые касаются элемента над которым она указана.
    Является SOURCE аннотацией указываемой над полями, методами, классами.


                                            @Retention
    Retention: RUNTIME;
    Target: ANNOTATION_TYPE;

    Данная аннотация задает "тип хранения" аннотации над которой она указана.
    Да эта аннотация используется даже для самой себя.
    Политика удержания аннотации (до какого этапа компилирования или выполнения видна)
    Значения лежат в перечислении RetentionsPolicy (SOURCE, CLASS, RUNTIME)


                                            @Target
    Retention: RUNTIME;
    Target: ANNOTATION_TYPE;

    Данная аннотация задает тип объекта над которым может указываться создаваемая нами аннотация.
    Да и она тоже используется для себя же.
    Значения берутся из перечесления (enum) ElemetType - FIELD, METHOD, TYPE(класс, интерфейс, перечисление)



                                    Пользовательские аннотации

    Мы можем создавать свои аннотации, например, для реализации следующей функциональности:

    Уменьшение дублирования кода.

    Автоматизация генерации бойлерплейт кода.

    Отлов ошибок во время компиляции, например, потенциальные Null Pointer Exception.

    Настройка поведения в рантайме на основе наличия аннотации.

    Создание аннотаций
    public @interface Author{

    поля(элементы) аннотаций объявляются как методы:
    String name();
    int dateOfBirth();

    Но используются, как поля:
    @Author(name = "Steven king", dateOfBirth = 1947
    public class test(){
    }

    Значение поля по умолчанию:
    String name() default "Some name";
    int dateOfBirth default 2000();


*/
    @Annotation_Syntax(author = "Alex", dateOfCreation = 2022, purpes = "Print Hello Word")
    public static void helloWord(){
        System.out.println("Hello Word");
    }
}