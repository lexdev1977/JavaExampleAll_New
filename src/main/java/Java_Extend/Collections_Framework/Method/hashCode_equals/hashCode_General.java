package Java_Extend.Collections_Framework.Method.hashCode_equals;

public class hashCode_General {

    /*

                                Метод hashCode()

     Метод hashCode позволяет задать некоторое числовое значение,
     которое будет соответствовать данному объекту или его хэш-код.
     По данному числу, например, можно сравнивать объекты.
     Еще стоит отметить, что входящие данные могут быть произвольной длины,
     а хеш код мы получаем фиксированной.
     Функция, реализующая данный алгоритм, называется - "хеш функцией" или "функцией свертки",
     в нашем случае  Метод hashCode() - та самая функция.

     Ситуация когда два хеш кода равны, но при этом сами объекты разные называется -  "Коллизией"
     возникает это из за того, что колличество хеш кодов ограничено.


     Например:

     Person tom = new Person("Tom");
     System.out.println(tom.hashCode()); // 2036368507


     Но мы можем задать свой алгоритм определения хэш-кода объекта:

     Например:

     class Person {

     private String name;

     public Person(String name){
     this.name=name;
        }

    @Override
    public int hashCode(){
        return 10 * name.hashCode() + 20456;    // здесь мы задали свой алгоритм хеширования
                                                // можно даже убрать встроенный генератор хеша
                                                // и полностью вставить свою реализацию
        }
    }



     Метод hashCode() может использоваться для неточного, но очень быстрого сравнения

     Представьте, что вы сортируете в алфавитном порядке список из тысяч слов,
     и вам нужно постоянно попарно сравнивать слова. А слова длинные, и букв в них много.
     В общем, такое сравнение будет идти очень долго.

     Однако его можно ускорить. Допустим, слова начинаются на разные буквы: сразу же понятно, что они разные.
     Вот если они начинаются на одинаковые буквы, тогда гарантий нет:
     в дальнейшем слова могут оказаться и равными, и различными

     Метод hashCode() работает по похожему принципу.
     Если его вызвать у объекта, то он вернет некое число — аналог первой буквы в слове.
     Это число обладает такими свойствами:

     * У одинаковых объектов всегда одинаковые hash-code
     * У разных объектов могут быть одинаковые hash-code, а могут быть разные
     * Если у объектов разные hash-code, объекты точно разные

     Последнее свойство и используется для ускоренного сравнения объектов:

     Сначала у двух объектов вычисляются hash-code. Если эти hash-code разные,
     то объекты точно разные, и сравнивать их дальше не нужно.

     А вот если hash-code одинаковые, придется все же сравнивать объекты с помощью equals

     !!! Если поля объекта объявлены как Final
     и их значения один раз задаются в конструкторе и больше не изменяются
     то и хеш код у объекта всегда один и тот же
     можно один раз вычислить хеш и записть его в переменную,
     а метод .hashCode будет просто возвращать это вычисленный хеш код (переменную)

     а затем сравнивать в методе equals его хеш код в переменной с хеш кодом сравниваемого объекта,
     и если они разные, тогда нет смысла дальше проводить, какие либо сравнения,
     что может в разы ускорить работу приложения, особенно если полей очень много.



                             Контракты в коде


    Все Java-программисты договорились, что если они пишут свою реализацию метода equals()
    вместо стандартной (из класса Object), они также должны написать свою реализацию метода hashCode(),
    чтобы озвученные выше правила сохранялись.

    Такая договоренность называется контрактом.

    Если вы добавляете в свой класс только реализацию одного метода equals() или только hashCode(),
    вы грубо нарушаете контракт (нарушаете договоренность). Так делать нельзя.

    Если другие программисты будут использовать ваш код, он может работать неправильно.
    Более того, вы тоже будете использовать код, который работает на основе вышеозвученных контрактов.

    Важно!
    Все коллекции в Java при поиске элемента внутри коллекции сначала сравнивают hash-code объектов,
    а только потом вызывают для сравнения метод equals.

    Поэтому если вы напишете свой класс, а в нем новую функцию equals, но не напишете метод hashCode()
    или реализуете его с ошибками, коллекции могут неправильно работать с вашими объектами.

    Например, вы добавили объект в список, затем ищете его с помощью метода contains(),
    а коллекция ваш объект не находит.


    Важно не забывать!!!
    Если мы создаем  HashMap и помещаем в качестве ключа какой то объект
    ( к примеру , contact01 (id: 10, name: "Alex", phone "+996555222222")

    HashMap <Contact, String> adressMap = new HashMap <>();

    addressMap.put(contact01, "Bishkek, Kyrgyzstan");

    А, теперь мы изменяем телефон в объекте, который у нас используется в качестве ключа

    contact01.phone = "+996555333333";

    теперь попробуем взять инфо о контакте

    System.out.println (addressMap.get(contact01));
    Мы получаем null
    После того, как мы изменили данные в контакте, а контакт является ключом в таблице
    то его хеш, тоже поменялся и мы уже больше не може по нему извлеч, данные адреса

    Получается, что по контакту с новым телефоном будет null и по старому тоже будет null

    Что же получилось - по контакту первому, нас не пускают так как изменился хеш код,
    а по новому контакту, но со старым адрессом, нас не пускают, так как он сверяется по equals со
    старым контактом

    Нужно очень внимательно отсносится к объектам, у которые являются ключами в Hash таблице,
    нельзя их менять, а лучше сделать их не изменяемыми

    Также нужно не забывать переопределять equals и HashCode одновременно!!!










     */


}


