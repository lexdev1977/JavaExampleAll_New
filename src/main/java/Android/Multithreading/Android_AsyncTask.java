package Android.Multithreading;

public class Android_AsyncTask {
/*

                                                Класс AsyncTask
                                                                                                                                                    *//**
    <!-- class myTask extends AsyncTask<[То что передаем], [возврат в ходе выполнения], [вернет после выполнения]>

    <!-- AsyncTask<[Input_Parameter Type], [Progress_Report Type], [Result Type]>                                                                       *//*


    Создание новой асинхронной задачи

    Класс AsyncTask предлагает простой и удобный механизм для перемещения трудоёмких операций в фоновый поток.
    Благодаря ему вы получаете удобство синхронизации обработчиков событий с графическим потоком,
    что позволяет обновлять элементы пользовательского интерфейса для отчета о ходе выполнения задачи
    или для вывода результатов, когда задача завершена.

    Следует помнить, что AsyncTask не является универсальным решением для всех случаев жизни.
    Его следует использовать для не слишком продолжительных операций - загрузка небольших изображений,
    файловые операции, операции с базой данных и т.д.

    Напрямую с классом AsyncTask работать нельзя (абстрактный класс), вам нужно наследоваться от него (extends).
    Ваша реализация должна предусматривать классы для объектов, которые будут переданы в качестве параметров
    методу execute(), для переменных, что станут использоваться для оповещения о ходе выполнения,
    а также для переменных, где будет храниться результат. Формат такой записи следующий:                                                               *//**

    AsyncTask<[Input_Parameter Type], [Progress_Report Type], [Result Type]>                                                                            *//*

    Если не нужно принимать параметры, обновлять информацию о ходе выполнения или выводить конечный результат,
    просто укажите тип Void во всех трёх случаях. В параметрах можно использовать только обобщённые типы (Generic),
    т.е. вместо int используйте Integer и т.п.

    Соответственно, варианты могут быть самыми разными. Вот несколько из них

    AsyncTask<Void, Void, Void>
    AsyncTask<String, Integer, Integer>
    AsyncTask<String, Void, Integer>
    AsyncTask<String, Integer, String>                                                                                                          *//**

    <!-- Для запоминания можно смотреть на схему - https://disk.yandex.com/i/KC_nJJfcMy-BYw

    <!-- Схема работы AsyncTask - https://disk.yandex.com/i/RykFdg-16aWXzw                                                                    *//*

    Каркас реализации AsyncTask, в котором используются строковой параметр и два целочисленных значения,
    нужных для оповещения о выполнении работы и о конечном результате:                                                                                  *//**


    private class MyAsyncTask extends AsyncTask<String, Integer, Integer> {
        @Override
        protected Integer doInBackground(String... parameter) {
            int myProgress = 0;
            <!-- [... Выполните задачу в фоновом режиме, обновите переменную myProgress...]
            publishProgress(myProgress);
            <!-- [... Продолжение выполнения фоновой задачи ...]
            <!-- Верните значение, ранее переданное в метод onPostExecute
            return result;
        }

        @Override
        protected void onProgressUpdate(Integer... progress) {
        <!-- [... Обновите индикатор хода выполнения, уведомления или другой
        <!-- элемент пользовательского интерфейса ...]
        }

        @Override
        protected void onPostExecute(Integer... result) {
        <!-- [... Сообщите о результате через обновление пользовательского
        <!-- интерфейса, диалоговое окно или уведомление ...]
        }
    }                                                                                                                                                                   *//*

    У AsyncTask есть несколько основных методов, которые нужно освоить в первую очередь.
    Обязательным является метод doInBackground(), остальные используются исходя из логики вашего приложения.

    - doInBackground() (выполняется в фоновом потоке, должен возвращать определенный результат)
      – основной метод, который выполняется в новом потоке. Не имеет доступа к UI.
      Именно в этом методе должен находиться код для тяжёлых задач. Принимает набор параметров тех типов,
      которые определены в реализации вашего класса. Этот метод выполняется в фоновом потоке,
      поэтому в нем не должно быть никакого взаимодействия с элементами пользовательского интерфейса.
      Размещайте здесь трудоёмкий код, используя метод publishProgress(), который позволит
      обработчику onProgressUpdate() передавать изменения в пользовательский интерфейс.
      Когда фоновая задача завершена, данный метод возвращает конечный результат для обработчика onPostExecute(),
      который сообщит о нём в поток пользовательского интерфейса.

    - onPreExecute() (вызывается из главного потока перед запуском метода doInBackground())
      – выполняется перед doInBackground(). Имеет доступ к UI

    - onPostExecute() (выполняется из главного потока после завершения работы метода doInBackground() )
      – выполняется после doInBackground() (может не вызываться, если AsyncTask был отменен).
      Имеет доступ к UI. Используйте его для обновления пользовательского интерфейса,
      как только ваша фоновая задача завершена. Данный обработчик при вызове синхронизируется с потоком GUI,
      поэтому внутри него вы можете безопасно изменять элементы пользовательского интерфейса.

    - onProgressUpdate().( позволяет сигнализировать пользователю о выполнении фонового потока )
      - Имеет доступ к UI. Переопределите этот обработчик для публикации промежуточных
      обновлений в пользовательский интерфейс. При вызове он синхронизируется с потоком GUI,
      поэтому в нём вы можете безопасно изменять элементы пользовательского интерфейса.

    - publishProgress() - (например статус бар, показывать строку загрузки)
      - можно вызвать в doInBackground() для показа промежуточных результатов в onProgressUpdate()

    - cancel() - отмена задачи

    - onCancelled() - Имеет доступ к UI. Задача была отменена. Имеются две перегруженные версии.


    Вкратце о том, что значит имеет/не имеет доступ к UI. Все ваши кнопки, текстовые метки, ImageView
    (всё, что отображается на экране) являются частью пользовательского интерфейса - User Interface (UI).
    Ваша задача - не допустить, чтобы в методе doInBackground() было обращение к какому-нибудь элементу.
    Например, нельзя установить текст в TextView через метод setText() или поменять цвет шрифта в EditText.

    На заметку: Несмотря на то, что студия генерирует строки super.onPreExecute() и super.onPostExecute()
    для соответствующих методов, вы их можете удалить. В исходниках суперкласса методы ничего не делают
    (это просто заглушка), поэтому во многих примерах в интернете они опущены. Пусть вас это не пугает.


























 */


}
