package Android.RecyclerView;

public class Android_RecyclerView {
/*
                                                RecyclerView


    Для добавления зависимости переходим в Gradle Scripts \ Build Gradle (Module...) и в dependencies {}
    вставляем строчку:                                                                                                                                                           *//**

    implementation 'com.android.support:recyclerview-v7:+'       (где v7 - версия, как вариант можно v7:28.0.0)                                                                                              *//*

    актуальная версия на 2022 -
                                                                                                                                                            *//**
    implementation "androidx.recyclerview:recyclerview-selection:1.1.0"                                                                                                     *//*

    после добавления нажать в верхнем углу Sync Now

    !!! в современном Андроиде зависимость уже встроена




                                            Части и функции RecyclerView

    RecyclerView обрабатывает некоторые задачи внутри (например, прокрутку и перезапуск представлений),
    но по сути это менеджер, который координирует вспомогательные классы для отображения коллекции.
    RecyclerView делегирует задачи следующим вспомогательным классам:

    - Adapter — увеличивает макеты элементов (создает экземпляр содержимого файла макета)
      и привязывает данные к представлениям, отображаемым в объекте RecyclerView.
      Адаптер также сообщает о событиях щелчка элемента.

    - LayoutManager — измеряет и позиционирует представления элементов в политике для повторного
     использования представлений RecyclerView и управляет ею.

    - ViewHolder — ищет и сохраняет ссылки на представления. Владелец представления также помогает обнаруживать
     щелчки по представлению элементов.

    - ItemDecoration — позволяет приложению добавлять специальные смещения рисунков и макетов в определенные
     представления для разделителей рисования между элементами, выделениями и границами визуальной группировки.

    - ItemAnimator — определяет анимации, происходящие во время действий элемента или при внесении изменений в адаптер.


    Связь между RecyclerViewLayoutManagerклассами и Adapter классами показана на следующей схеме:

    https://disk.yandex.com/i/-WHf6fCUpk9V0Q


    Как показано на этом рисунке, LayoutManager можно рассматривать как посредник между Adapter и тем RecyclerView.
    Выполняет LayoutManager вызовы Adapter методов от имени объекта RecyclerView.
    Например, метод LayoutManager вызывается Adapter, когда нужно создать новое представление
    для определенной позиции элемента в элементе RecyclerView. Макет Adapter для этого элемента задувается
    и создает ViewHolder экземпляр (не показан) для кэширования ссылок на представления в этой позиции.
    Когда вызывает LayoutManagerAdapter привязку определенного элемента к набору данных,
    Adapter он находит данные для этого элемента, извлекает его из набора данных
    и копирует его в связанное представление элемента.


    При использовании RecyclerView в приложении требуется создание производных типов следующих классов:

    - RecyclerView.Adapter — предоставляет привязку из набора данных приложения (который относится к вашему приложению)
      к представлениям элементов, отображаемым в элементе RecyclerView. Адаптер знает, как связать каждую позицию
      представления элемента в RecyclerView определенном расположении в источнике данных.
      Кроме того, адаптер обрабатывает макет содержимого в каждом отдельном представлении элементов
      и создает держатель представления для каждого представления. Адаптер также сообщает события щелчка элемента,
      обнаруженные представлением элемента.

    - RecyclerView.ViewHolder — кэширует ссылки на представления в файле макета элемента,
      чтобы поиск ресурсов не повторялся без необходимости. Владелец представления также упорядочивает
      события щелчка элемента, которые будут переадресовывать адаптеру, когда пользователь касается
      связанного представления элемента владельца представления.

    - RecyclerView.LayoutManager — позиционирует элементы внутри RecyclerViewэлемента.
      Можно использовать один из нескольких стандартных диспетчеров макетов или реализовать собственный
      пользовательский диспетчер макетов. RecyclerView делегирует политику макета диспетчеру макетов,
      поэтому вы можете подключить другой диспетчер макетов без внесения значительных изменений в приложение.

      Кроме того, можно дополнительно расширить следующие классы, чтобы изменить внешний вид
      и внешний RecyclerView вид в приложении:

    - RecyclerView.ItemDecoration
    - RecyclerView.ItemAnimator
      Если вы не расширяете ItemDecoration и ItemAnimatorRecyclerView используете реализации по умолчанию.


    Как работает переработка представлений

    RecyclerView не выделяет представление элемента для каждого элемента в источнике данных.
    Вместо этого он выделяет только количество представлений элементов, которые помещаются на экране,
    и повторно использует эти макеты элементов при прокрутке пользователя.
    Когда представление сначала прокручивается вне видимости, он проходит через процесс переработки,
    показанный на следующем рисунке:

    https://disk.yandex.com/i/4dP1hY5eEYtwBQ

    - Когда представление прокручивается вне видимости и больше не отображается, он становится представлением слома.

    - Представление слом помещается в пул и становится представлением корзины. Этот пул представляет собой
      кэш представлений, отображающих один и тот же тип данных.

    - При отображении нового элемента представление берется из пула перезапуска для повторного использования.
      Так как это представление должно быть повторно привязано адаптером перед отображением, оно называется "грязным".

    - Грязное представление перезапускается: адаптер находит данные для отображения следующего элемента
      и копирует эти данные в представления для этого элемента. Ссылки на эти представления извлекаются
      из владельца представления, связанного с переработанным представлением.

    - Переработанное представление добавляется в список элементов, RecyclerView которые собираются перейти на экран.

    - Переработанное представление переходит на экран, когда пользователь прокручивает RecyclerView
      следующий элемент в списке. Между тем, другое представление прокручивается вне видимости
      и перезапускается в соответствии с приведенными выше шагами.

    Помимо повторного использования представления элементов, RecyclerView также используется другая
    оптимизация эффективности: держатели представлений. Держатель представления — это простой класс,
    который кэширует ссылки на представления. Каждый раз, когда адаптер увеличивает файл макета элемента,
    он также создает соответствующий держатель представления. Владелец представления используется
    для FindViewById получения ссылок на представления внутри файла макета элемента.
    Эти ссылки используются для загрузки новых данных в представления при каждом перезапуске макета
    для отображения новых данных.



    Диспетчер макетов

    Диспетчер макетов отвечает за размещение элементов на RecyclerView экране;
    определяет тип презентации (список или сетку), ориентацию (отображение элементов по вертикали или по горизонтали)
    и отображение элементов направления (в обычном порядке или в обратном порядке).
    Диспетчер макетов также отвечает за вычисление размера и положения каждого элемента в отображении RecycleView.

    Диспетчер макетов имеет дополнительную цель: он определяет политику для того, когда следует перезапускать
    представления элементов, которые больше не видны пользователю. Так как диспетчер макетов знает,
    какие представления видны (и которые нет), лучше всего решить, когда представление может быть переработано.
    Для перезапуска представления диспетчер макетов обычно вызывает адаптер для замены содержимого переработанного
    представления различными данными, как описано выше в разделе «Как работает переработка представлений».

    Вы можете расширить RecyclerView.LayoutManager возможности для создания собственного диспетчера макетов
    или использовать предопределенный диспетчер макетов. RecyclerView предоставляет следующие предопределенные
    диспетчеры макетов:

    - LinearLayoutManager — упорядочивает элементы в столбце, который можно прокручивать по вертикали или в строке,
      которую можно прокручивать по горизонтали.

    - GridLayoutManager — отображает элементы в сетке.

    - StaggeredGridLayoutManager — отображает элементы в ошеломленной сетке,
      где некоторые элементы имеют разные высоты и ширины.

    Чтобы указать диспетчер макетов, создайте экземпляр выбранного диспетчера макетов
    и передайте его в SetLayoutManager метод. Обратите внимание, что необходимо указать диспетчер макетов.
    RecyclerView По умолчанию не выбирается стандартный диспетчер макетов.


    Держатель представления

    Владелец представления — это класс, который определяется для ссылок на представление кэширования.
    Адаптер использует эти ссылки на представление для привязки каждого представления к его содержимому.
    Каждый элемент в элементе RecyclerView имеет связанный экземпляр владельца представления,
    который кэширует ссылки на представление для этого элемента. Чтобы создать держатель представления,
    выполните следующие действия, чтобы определить класс для хранения точного набора представлений для каждого элемента:

    Подкласс RecyclerView.ViewHolder.
    Реализуйте конструктор, который ищет и сохраняет ссылки на представление.
    Реализуйте свойства, которые адаптер может использовать для доступа к этим ссылкам.


    Адаптер

    Большая часть кода интеграции выполняется RecyclerView в адаптере. RecyclerView требует,
    чтобы указать адаптер, производный от RecyclerView.Adapter доступа к источнику данных,
    и заполнить каждый элемент содержимым из источника данных. Так как источник данных зависит от приложения,
    необходимо реализовать функциональные возможности адаптера, которые понимают, как получить доступ к данным.
    Адаптер извлекает сведения из источника данных и загружает их в каждый элемент в RecyclerView коллекции.

    На следующем рисунке показано, как адаптер сопоставляет содержимое в источнике данных
    с помощью держателей представлений с отдельными представлениями в каждом элементе RecyclerViewстроки в:

    https://disk.yandex.com/i/bvbnMcmyLs5Sag







                                           Из другой статьи


    RecyclerView – это компонент пользовательского интерфейса, который позволяет нам создавать прокручиваемый список.
    Он был представлен в Android Lollipop

    RecyclerView, по сути, является эволюцией одного из самых необходимых в Android-разработке виджетов — ListView.
    Собственно, предназначение у него ровно то же самое — отображать список элементов, но есть нюансы:


    - Обязательное использование паттерна ViewHolder

    - LayoutManager. Для использования RecyclerView кроме адаптера вам необходимо передать ему
      с помощью метода setLayoutManager() объект класса, реализующего LayoutManager. Этот класс отвечает за работу
      с адаптером, именно он решает, переиспользовать View или создать новый, и соответственно,
      именно он дёргает методы onCreateViewHolder(), onBindViewHolder() и getItemCount() адаптера.
      Пока доступна только одна реализация этого класса — LinearLayoutManager, для создания кастомного LayoutManager,
      необходимо унаследоваться от RecyclerView.LayoutManager.

    - Анимация операций со списком. В презентации дизайна Material одной из основных его особенностей
      является плавность UI, которая достигается с помощью повсеместного использования анимации.
      В RecyclerView это делается парой строчек кода:
      для объекта RecyclerView указывается класс, имплементирующий анимацию:
                                                                                                                                                                *//**
      RecyclerView.ItemAnimator itemAnimator = new DefaultItemAnimator();
        recyclerView.setItemAnimator(itemAnimator);                                                                                                                      *//*

      при добавлении или удалении элемента списка вызывается метод адаптера notifyItemInserted(int position)
      или notifyItemRemoved(int position) соответственно.
      При желании можно написать собственную реализацию анимации, унаследовавшись от RecyclerView.ItemAnimator.


    Чтобы реализовать RecyclerView, мы должны создать следующие компоненты:

    - RecyclerView, который мы должны добавить в layout нашего экрана;
    - layout для каждой строки списка;
    - адаптер, который содержит данные и связывает их со списком.



                                    Последовательност создания

    - Добавление RecyclerView в layout activity_main.xlm:                                                                                                                *//**
<!--        <androidx.recyclerview.widget.RecyclerView> в activity_main                                                                                                               *//*



    - Создание RecyclerView в Activity:                                                                                                                         *//**
<!--        RecyclerView recyclerView;                      // создание объекта класса  RecyclerView
<!--        recyclerView = findViewById(R.id.rv_recycler);  // подключение к готовому RecyclerView в activity_main.xlm

<!--        recyclerView.setHasFixedSize(true);             // Если размер RecyclerView не будет изменяться
<!--                                                        // можно добавить этот код для улучшения производительности:
                                                                                                                                                                                                                                 *//*


    - Установка LayoutManager   (отвечает за позиционирование view-компонентов в RecyclerView,
      а также за определение того, когда следует переиспользовать view-компоненты, которые больше не видны пользователю.)
      Другие варианты LayoutManager -  GridLayoutManager, StaggeredGridLayoutManager или WearableLinearLayoutManager.                                                                                                                            *//**

<!--       LinearLayoutManager LayoutManager = new LinearLayoutManager(this); //  используем LinearLayoutManager
<!--       recyclerView.setLayoutManager(LayoutManager);                                                                                                                               *//*


    - Создать layout для строки списка
      создаем новый xml файл в layout    New / Layout Resource File
      и настраиваем его в соответствии с требованиями к нашему элементу списка используя компоненты View
                                                                                                                                                        *//**
<!--       файл - item_recycler_view
<!--       <FrameLayout...><TextView>...<TextView><FrameLayout>  // например                                                                                                     *//*


    - создаем класс ViewHolder, можно как отдельным, вложенным или анонимным классов прям в методе onCreateViewHolder()
                                                                                                                                                                            *//**
            public class Holder extends RecyclerView.ViewHolder{ // класс наследник RecyclerView.ViewHolder
            TextView textView;

            public Holder(View itemView) {                       // реализация конструктора
            super(itemView);

            textView = itemView.findViewById(R.id.textView);
                                                                                                                                                                                } *//*


    - создаем адаптер, который в качестве параметра принимает класс, наследующий RecyclerView.ViewHolder
                                                                                                                                            *//**
<!--        public class Adapter extends RecyclerView.Adapter<Holder>  // создаем класс наследующий RecyclerView.Adapter

         public Adapter(int numberItems) {   // создаем конструктор, которому на вход задаем число элементов списка
         this.numberItems = numberItems;
       }                                                                                                                                          *//*

      Также необходимо переопределить некоторые требуемые методы

       * getItemCount() возвращает общее количество элементов списка. Значения списка передаются с помощью конструктора.                                                   *//**
                public int getItemCount() {
                return numberItems;
              }                                                                                                                                                             *//*

       * onCreateViewHolder() создает новый объект ViewHolder всякий раз, когда RecyclerView нуждается в этом.
         Это тот момент, когда создаётся layout строки списка, передается объекту ViewHolder,
         и каждый дочерний view-компонент может быть найден и сохранен.
         Мы указываем макет для каждого элемента RecyclerView.
         Затем LayoutInflater заполняет макет, и передает его в конструктор ViewHolder.


       * onBindViewHolder() принимает объект ViewHolder и устанавливает необходимые данные для соответствующей строки
         во view-компоненте. (определяем содержимое каждого элемента из RecyclerView)



                                        Почему нам нужен паттерн ViewHolder?
        Короче говоря, ViewHolder предотвращает ненужные вызовы findViewById().
        Если layout строки списка не создаётся для каждой строки, тогда сколько раз на самом деле он создаётся?
        Сколько раз вызываются методы onCreateViewHolder() и onBindViewHolder()?






























 */


}
