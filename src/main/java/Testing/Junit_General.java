package Testing;

public class Junit_General {
/*
                                    !!!Само описание junit, после описание методов и классов -->

    Конвенция:
    - Тестовый класс необходимо называть с суффиксом Test (например Vector2DTest)
    - Хорошо если тестовые методы содержат "Should" (должен) например (sumShouldBePositive)


    - Аннотация @Test - объявляет метод тестовым, тестовые методы должны быть - public void
    - Аннотация @Test - может использовать дополнительные параметры:

       - expected - код в тесте проверяется на генерацию определенного исключения
           пример: @Test(expected =  ArithmeticException.class)
       - timeout - код в тесте должен работать не более указанного времени (иначе тест завален)
           пример: @Test

    - Аннотация @Ignore - помеченный тест не выполняется, лучше не использовать



                                            org.junit.Assert

    org.junit.Assert - класс для сопоставления ожидания и реальности (expected/actual), имеет множество методов

    Например:

    - assertEquals() и assertNotEquals() - используется для подтверждения того,
                                            что ожидаемое и фактическое значения равны.
    - assertArrayEquals() -                 Метод assertArrayEquals() утверждает, что ожидаемый
                                            и фактический массивы равны.
    - assertIterableEquals() -              Метод assertIterableEquals() утверждает,
                                            что ожидаемые и фактические итерации полностью равны.
    - assertLinesMatch() -                  Он утверждает, что ожидаемый список строк соответствует фактическому списку
    - assertNotNull() и assertNull() -      AssertNotNull() утверждает, что фактическое значение НЕ равно нулю.
                                            Точно так же метод assertNull() утверждает, что это действительно так null.
    - assertNotSame() -                     утверждает, что ожидаемый и фактический не относятся к одному объекту.
    - assertSame() -                        утверждает, что ожидаемый и фактический относятся к одному и тому же объекту.
    - assertTrue() -                        утверждает, что предоставленное условие истинно
                                            или предоставленное логическое условие BooleanSupplier истинно.
    - assertFalse() -                       утверждает, что предоставленное условие ложно.
    - assertThrows() -                      утверждает, что исполнение подаваемы Executable генерирует исключение
                                            из expectedType и возвращает исключение.
    - fail() -                              делает тест неуспешным.

    !!!Наличие методов может отличаться в разных версиях Junit


                                            org.junit.Assume

    Класс идентичен Assert, со своими методами, но в случае провала теста, тест просто игнорируется



                              Жизненный цикл JUnit (многое относится к JUnit 5)

    В JUnit 5 жизненный цикл теста управляется четырьмя основными аннотациями,
    то есть @BeforeAll, @BeforeEach, @AfterEach и @AfterAll.
    Вместе с тем, каждый тестовый метод должен быть помечен аннотацией @Test из пакета org.junit.jupiter.api.

    Обычно тестовый класс содержит несколько тестовых методов.
    JUnit управляет выполнением каждого метода тестирования в форме жизненного цикла.

    Полный жизненный цикл тестового сценария можно разделить на три фазы с помощью аннотаций.

    - 1. Setup (настройка): на этом этапе создается тестовая инфраструктура.
    JUnit обеспечивает настройку уровня класса (@BeforeAll) и настройку уровня метода (@BeforeEach).
    Как правило, тяжелые объекты, такие как подключения к базам данных, создаются при настройке уровня класса,
    в то время как легкие объекты, такие как тестовые объекты, перезапускаются при настройке уровня метода.

    - 2. Test Execution (выполнение теста): на этом этапе происходит выполнение теста и assertion.
    Результат выполнения будет означать успех или неудачу теста.

    - 3. Cleanup (очистка): этот этап используется для очистки настройки тестовой инфраструктуры,
    настроенной на первом этапе. Как на этапе настройки, очистка также выполняется на уровне класса (@AfterAll)
    и уровне метода (@AfterEach).


    @BeforeAll     -->     @BeforeEach   -->     @Test -->     @AfterEach     -->     @AfterAll
    Class Level            Setup                 Test          Cleanup                Class Level
    Setup                   ^                    Execution        ^                    Cleanup
                            |                                     |
                            |_________Repeat______________________|



                                         Аннотации Before и After

    Как показано выше, в жизненном цикле теста нам в первую очередь потребуются аннотированные методы для настройки
    и очистки тестовой среды или тестовых данных, на которых выполняются тесты.

    В JUnit по умолчанию для каждого метода тестирования создается новый экземпляр теста.

    Аннотации @BeforeAll и @AfterAll - понятные по названию - должны вызываться только один раз
    за весь цикл выполнения тестов. Поэтому они должны быть объявлены static.

    @BeforeEach и @AfterEach вызываются для каждого экземпляра теста, поэтому они не должны быть static.

    Если есть несколько методов, помеченных одной и той же аннотацией (например, два метода с @BeforeAll),
    то порядок их выполнения не определен.

                                                                                                                   *//**
        public class AppTest {

        @BeforeAll
        static void setup(){
            System.out.println("@BeforeAll executed");
        }

        @BeforeEach
        void setupThis(){
            System.out.println("@BeforeEach executed");
        }

        @Test
        void testCalcOne()
        {
            System.out.println("======TEST ONE EXECUTED=======");
            Assertions.assertEquals( 4 , Calculator.add(2, 2));
        }

        @Test
        void testCalcTwo()
        {
            System.out.println("======TEST TWO EXECUTED=======");
            Assertions.assertEquals( 6 , Calculator.add(2, 4));
        }

        @AfterEach
        void tearThis(){
            System.out.println("@AfterEach executed");
        }

        @AfterAll
        static void tear(){
            System.out.println("@AfterAll executed");
       }                                                                                                            *//*

      Тестовый вывод:                                                                                              *//**

        @BeforeAll executed

        @BeforeEach executed
        ======TEST ONE EXECUTED=======
        @AfterEach executed

        @BeforeEach executed
        ======TEST TWO EXECUTED=======
        @AfterEach executed

        @AfterAll executed
                                                                                                                    *//*

                                         Отключение тестов

    Чтобы отключить тест в JUnit 5, вам нужно будет использовать аннотацию @Disabled.
    Это эквивалентно аннотации @Ignored JUnit 4.

    Аннотация @Disabled может быть применена к классу тестирования (отключает все методы тестирования в этом классе)
    или к отдельным методам тестирования.
                                                                                                                   *//**
        @Disabled
        @Test
        void testCalcTwo()
        {
            System.out.println("======TEST TWO EXECUTED=======");
            Assertions.assertEquals( 6 , Calculator.add(2, 4));
        }                                                                                                           *//*

                                                Assertions

    В любом методе тестирования нам нужно будет определить, прошел он или нет.
    Мы можем сделать это с помощью Assertions (утверждений).

    Утверждения помогают сравнить ожидаемый результат с фактическим результатом теста.
    Для простоты все утверждения JUnit Jupiter являются статическими методами в классе org.junit.jupiter.Assertions.

        @Test                                                                                                      *//**
        public void test()
        {
            //Test will pass
            Assertions.assertEquals(4, Calculator.add(2, 2));

            //Test will fail
            Assertions.assertEquals(3, Calculator.add(2, 2), "Calculator.add(2, 2) test failed");

            //Test will fail
            Supplier<String> messageSupplier  = ()-> "Calculator.add(2, 2) test failed";
            Assertions.assertEquals(3, Calculator.add(2, 2), messageSupplier);
        }                                                                                                           *//*

    Чтобы тест не прошел, просто используйте метод Assertions.fail().

        @Test                                                                                                      *//**
        void testCase() {

            Assertions.fail("not found good reason to pass");
        }                                                                                                           *//*

                                                Assumptions

    Assumptions (предположения) предоставляют static методы для поддержки выполнения условного теста
    на основе предположений. Неуспешное предположение приводит к прерыванию теста.

    Предположения обычно используются всякий раз, когда нет смысла продолжать выполнение данного метода тестирования.
    В отчете о тестировании эти тесты будут отмечены как пройденные.

    Класс предположений имеет три метода со многими перегруженными формами:

    assumeFalse(): проверяет, что данное предположение false.

    assumeTrue(): подтверждает данное предположение, чтобы быть true.

    assumingThat(): выполняет предоставленный метод Executable,
    но только если предоставленное предположение верно.
                                                                                                                   *//**
    @Test
    void testOnDev()
    {
        System.setProperty("ENV", "DEV");
        Assumptions.assumeTrue("DEV".equals(System.getProperty("ENV")));
        //remainder of test will proceed
    }

    @Test
    void testOnProd()
    {
        System.setProperty("ENV", "PROD");
        Assumptions.assumeTrue("DEV".equals(System.getProperty("ENV")));
        //remainder of test will be aborted
    }*                                                                                                              *//*


                                        *** JUnit – определение ***

    JUnit – специальная библиотека, необходимая для проведения модульного тестирования в Java.
    Портирована на разнообразные языки программирования. Активно используется разработчиками на практике.

    Представляет собой фреймворк, который отвечает за реализацию отдельных «самостоятельных» элементов
    имеющейся кодификации. Помогает разработчикам при продумывании концепций
    собственных схем теста программного обеспечения.

    JUnit представлена средой тестирования, обладающей открытым исходным кодом. Применяется для:

    - написания автоматического теста;
    - запуска соответствующей проверки.

    Применяется и в качестве отдельной Джава-программы, и в IDE среде. Пример – Eclipse.


                                        Ключевые особенности

    Для того, чтобы проверить работоспособность программного кода, нужно провести тест.
    Вручную это делать не всегда удобно. Поэтому на помощь приходит JUnit. Он отвечает за обеспечение:

    - утверждения результатов, получаемых в ходе «анализа»;
    - тестовых функций, применяемых при обмене общими полученными показателями;
    - наборов тестов, способных облегчить организацию и запуск проверки;
    - графические и текстовые тесты бегунов.

    Применяется на практике для того, чтобы осуществить проверку всего объекта,
    а также его части (методов или нескольких их групп, взаимодействующих между собой).
    Дополнительно JUnit проверяет слаженность и правильность работы нескольких объектов программного кода между собой.

    Важно: с использованием JUnit можно значительно упростить проверку работоспособности имеющейся утилиты.
    Данный «инструмент» довольно легко использовать на практике.


                                        Свойства JUnit

    JUnit в Java имеет следующие свойства:

    - открытый исходный код;
    - ускорение написания итоговой кодификации (даже самой сложной);
    - поддержка аннотаций для того, чтобы можно было идентифицировать методы;
    - поддержка утверждений для тестов;
    - возможность организации тестов в их связке;
    - визуальная удобная индикация.

    Пример последнего свойства можно увидеть, когда осуществляется непосредственный тест.
    Красным цветом выделяются текущие ошибки. Зеленым – те, что уже исправлены.
    Это очень удобно не только новичкам, но и продвинутым программерам.


                            Тестирование – каким бывает и при чем тут JUnit

    Если хотите получить программу, которая работает исправно и без ошибок,
    важно проводить перед началом активной работы с ней так называемый тест. Он бывает нескольких видов:

    - тест черного ящика;
    - тест белого ящика.

    В первом случае предстоит работать с учетом того, что внутренняя структура утилиты не принимается в расчет.
    Ключевой упор делается на функциональность, которую должен обеспечивать соответствующий контент.
    Если же говорить о тесте белого ящика, во внимание принимаются методы и классы внутреннего характера.

    Также тесты условно разделяют на несколько уровней:

    - юнит – отдельные участки имеющегося кода;
    - интеграционный – проверка взаимодействия и совместной работы компонентов контента;
    - системный – тест всей системы в качестве единого целого;
    - прием – конечная проверка на соответствие заданным изначально требованиям.

    Первый вариант – это всегда тестирование белого ящика. Других вариантов развития событий нет.
    JUnit здесь играет немаловажную роль. За счет него обеспечивается целостная проверка создаваемого контента.




           Понятие тестового примера (Test Case). Класс, содержащий тестовые примеры (методы). Запуск теста
           Test Case - тестовый сценарий, каждый такой сценарий - это отдельный метод

    При использовании механизма JUnit, рассматриваются две основные единицы (классы):

    - класс, методы которого нужно протестировать;
    - класс, который представляет собой JUnit тест. Этот класс построен по специальным правилам.

    Значит, JUnit-тест представляет собой специально разработанный класс, содержащий методы,
    которые тестируют программный код других классов. В системе Java Eclipse этот класс
    создается с помощью команды JUnit Test Case

    Класс содержит ряд методов. Каждый из методов тестирующего класса
    рассматривается как отдельный тестовый пример — Test Case.

    Тестовые примеры (методы) JUnit-класса могут быть объявлены с использованием следующих аннотаций
    (рассматривается версия Java Eclipse 2018-09):

    @BeforeAll — статический метод (тестовый пример), объявленный с этой инструкцией, вызывается в начале тестирования;

    @AfterAll — статический метод, объявленный с этой инструкцией, вызывается в конце тестирования.
    Здесь можно задавать, например, освобождение ресурсов используемых при тестировании;

    @Test — метод, который объявлен с этой инструкцией, является тестовым примером.
    Он содержит непосредственно код тестирования. Этот метод использует методы класса org.junit.jupiter.api.Assertions.
    В этом методе используются методы сравнения, которые начинаются с префикса assert*().
    Например, для сравнения двух значений любого примитивного типа используется перегруженный метод assertEquals().
    В одном тестовой классе JUnit может быть произвольное количество методов (примеров) тестирования,
    которые объявлены с аннотацией @Test;

    @BeforeEach — вызывается перед вызовом каждого тестового примера (метода), который объявлен с аннотацией @Test;

    @AfterEach — вызывается после завершения каждого тестового примера (метода), который объявлен с аннотацией @Test.
    Допускается произвольное количество методов со всеми вышеприведенными аннотациями.

    В наиболее общем случае, примерный вид класса, сгенерированный системой Java Eclipse, может быть таким:
                                                                                                                   *//**
     class TestClass {
          @BeforeAll
          static void setUpBeforeClass() throws Exception {
          }

          @AfterAll
          static void tearDownAfterClass() throws Exception {
          }

          @BeforeEach
          void setUp() throws Exception {
          }

          @AfterEach
          void tearDown() throws Exception {
          }

          @Test
          void testMethod() {
            fail("Not yet implemented");
          }
        }

        В методе testMethod() нужно вставить собственный код работы методов другого класса
                                                                                                                    *//*













 */

}
